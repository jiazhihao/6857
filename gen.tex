\section{Design}
\label{s:gen}

\autoref{f:flow} shows \sys's workflow.  Given the LLVM intermediate
representation~(IR) compiled from source code, \sys generates a set
of constraints for each integer operation, and feed them into the
Boolector constraint solver for deciding satisfiability.

Specifically, \sys generates three types of constraints.
%
Given an integer operation, the error constraint is generated
directly from definition.
%
\sys also calculates the path constraint, the predicate satisfying
which the operation is reachable from the start of that function.
%
To further improve accuracy, \sys infers additional range information
of function parameters and structure fields across the call graph.
It also allows users to provide annotations as constraints.

\begin{figure}
\centering
\resizebox{\linewidth}{!}{
\input{figs/flow}
}
\caption{\sys's workflow.  It generates constraints from the LLVM
intermediate representation~(IR) and user annotations, and then feeds
the constraints to a solver for satisfiability testing.}
\label{f:flow}
\end{figure}

\subsection{Error Constraint Generation}
\label{s:gen:err}

For arithmetic and shift operations, it is straightforward to
generate their error constraints from their definitions shown in
\autoref{s:sema:constr}.  As for $n$-bit unsigned multiplication,
one may use a $2n$-bit binary multiplier (extending both integers
from $n$ to $2n$ bits first), which flags an overflow error if any
of the most significant $n$ bits of the product is
1~\cite{molnar:catchconv}.

Boolector provides highly optimized Boolean circuits for implementing
some of these error constraints.  Its overflow detection circuit,
for example, does not even need to compute the $2n$-bit product and
thus can be solved far more
efficiently~\cite[\chapterautorefname~3.5]{brummayer:phd}.  \sys
reuses these circuits for better performance.

\sys deals with the two conversion cases as follows.

To detect tautological comparisons, \sys derives a predicate from
each comparison.  If the predicate is trivially true or false
resulted from an integer conversion within that function, \sys
reports the conversion as an integer error.

For negative counts, it is easy to generate the error constraint
for a value $x$ that should be conceptually non-negative, that is,
$x <_s 0$; however, \sys needs to know them first.  \sys implements
a front-end plugin to recognize array indices.  \sys also requires
user-provided annotations on ``size'' function parameters.  As for
the Linux kernel, we annotate parameters in functions like \cc{memcpy},
\cc{copy_from_user}, and \cc{sock_alloc_send_skb}.

\subsection{Path Constraint Generation}
\label{s:gen:path}

We use \autoref{f:ax25-sign} as an example to illustrate how \sys
generates path constraints.  The control flow of the code is shown
in \autoref{f:cfg}, where there are two sanity checks on \cc{optlen}
before it reaches \cc{copy_from_user}.  For clarification purpose
\cc{optlen} is numbered every time it is assigned a new
value~\cite[\chapterautorefname~8.11]{whale}.  Our goal is to
evaluate the path constraint for the call to \cc{copy_from_user}.

The basic algorithm works as follows.  Since there is no loop, the
path constraint of the call to \cc{copy_from_user} is simply the
logical OR of the constraint from each of its predecessors, namely
\textsc{If-True} and \textsc{If-False}.  For each predecessor, the
constraint is a logical AND of three parts: the branching condition,
possible assignment(s) in the predecessor, and the path constraint
of that predecessor.  Here both \textsc{If-True} and \textsc{If-False}
unconditionally jump to \cc{copy_from_user}, so their branching
conditions are simply true, which can be ignored.  Now we have the
path constraint as follows:
\newcommand{\optlen}{{\small \texttt{optlen}}}
\newcommand{\pc}{\textrm{PathConstraint}}
%
\begin{align*}
& ((\optlen_1 = 16) \land \pc(\textsc{If-True})) \\
\lor & ((\optlen_1 = \optlen_0) \land \pc(\textsc{If-False})).
\end{align*}

Recursively apply the algorithm to \textsc{If-True} and \textsc{If-False},
and we can get the fully expanded result:
%
\begin{align*}
& ((\optlen_1 = 16) \land (\optlen_0 >_s 16)
    \land \neg(\optlen_0 <_u 4)) \\
\lor & ((\optlen_1 = \optlen_0) \land \neg(\optlen_0 >_s 16) \\
     & \; \land \neg(\optlen_0 <_u 4)).
\end{align*}

One can feed the logical AND of the path constraint and the error
constraint (i.e., $\cc{optlen}_1 <_s 0$) into the solver, which
will reply with an error example, e.g., $\cc{optlen}_0 = -1$.

\begin{figure}
\centering
\resizebox{\linewidth}{!}{
\input{figs/cfg}
}
\caption{The control flow of the code snippet in \autoref{f:ax25-sign}.}
\label{f:cfg}
\end{figure}

For complex programs that contain loops, \sys handles them using
the standard unrolling technique~\cite{xie:saturn}.  The path
constraint generation algorithm unrolls each loop once and ignores
branching edges that jump back in the control flow, aka back edges.
The complete algorithm is listed in \autoref{f:path-cstr}.

\begin{figure}
\input{algo/path}
\caption{Algorithm for path constraint generation.}
\label{f:path-cstr}
\end{figure}

\subsection{Range Constraint Generation}
\label{s:gen:range}

\sys generates range constraints for function parameters
and structure fields.

%handle sysctl interface.


\subsection{Optimizations}

\sys performs a series of optimizations and rewrites the code for
fewer false errors and better performance.

\paragraph{In-loop constraint.}
\sys tries to move constraints within a loop to the outside scope
so as to generate more constraints.  Consider the following loop.
\input{code/loop}
\sys will generate an error constraint $i <_s 0$ since $i$ is used
as an array index.  As $i$ also is a loop variable, \sys will move
the constraint out of the loop and rewrite it as $n <_s 0$, by
substituting the loop variable $i$ with its exit value $n$.

\paragraph{Pointer arithmetic.}
\sys represents each pointer or memory address as a symbolic
expression~\cite{engelen:symbolic}, and tries to simplify it if
possible.  A pointer expression that \sys fails to simplify will
be considered as a black-box integer, which can be any value within
its range.  Consider the code snippet below.
%
\input{code/pid-ptrsub}
%
The offset of \cc{pidmap} in the structure \cc{pid_namespace} is 4
bytes, i.e., the size of \cc{kref}, thus \sys represents the address
\cc{pid_ns->pidmap} as $\cc{pid_ns} + 4$.  Here \cc{pid_ns} is
considered as a black box since no further information is available.

In addition, assuming the size of each element of \cc{pidmap} is 8
bytes, \sys represents the address \cc{\&pid_ns->pidmap[i]} as
$\cc{pid_ns} + 4 + i \times 8$; in this example we have $i =
(\cc{last} + 1) /_u \cc{BITS_PER_PAGE}$.  Thus, the value of \cc{off},
the subtraction of the two pointers, is reduced to $(\cc{pid_ns} +
4 + i \times 8) - (\cc{pid_ns} + 4) = i \times 8$.

\paragraph{Memory model.}
\sys employs a very simple memory model: a load instruction may return
an arbitrary value (unless it has a range constraint; see
\autoref{s:gen:range}).  It relies on LLVM's load elimination
algorithm to merge load instructions that will return the same
value.

There are two problems when directly applying LLVM's load elimination
algorithm.
%
First, the algorithm optimizes for performance and tends to delay
load instructions.  This would result in multiple load instructions,
often in spanned in several branches, that are in fact identical.
%
Second, the algorithm depends on LLVM's pointer analysis algorithm,
which is over-conservative.  For example, XXX.

\sys addresses the problems by hoisting every load instruction to
the earliest possible point within the function.  The hope is that
those load instructions will be moved up and put closed to each
other, so that the load elimination algorithm can easily merge them
if they are identical.

Consider a load instruction $L$ that loads from pointer $p$.  $L$ is
safe to move across its previous instruction $I$ if:
\begin{itemize}
\item $I$ does not write to any memory location, or
\item $I$ writes to pointer $q$, while $p$ and $q$ never point to the
same memory location, i.e., they do not alias.
\end{itemize}

\sys repeatedly hoists $L$ until it is unsafe to do so and $L$
reaches the entry block.  If $L$ is already the first instruction
in a non-entry block and there are multiple predecessors that jump
to $I$, \sys tries to move $L$ up to the common ancestor.

\sys also adopts an aliasing assumption: a pointer passed as a
function parameter or a global variable points to a memory location
is distinct from any other memory location.  This assumption, though
unsound, has been proven to be practical for detecting bugs C
programs~\cite{livshits:ipssa}.  It allows the hoisting algorithm
to aggressively push load instructions ahead for more elimination
opportunity.

In practice we find out that this memory model works well for \sys.
It does not require sophisticated analysis across the whole kernel
and achieves good performance.  See [[eval]]].

\if 0
\begin{figure}
\input{algo/hoist}
\caption{The hoisting algorithm to move a load instruction to the
earliest possible point within a function.  It repeats the two
phases: first try to move the instruction to the beginning of its
basic block; if successful, try to move it into the common ancestor
of the block's predecessors.}
\label{f:hoist}
\end{figure}
\fi

\paragraph{Error-before-check.}
An integer error check may come after the overflowed computation,
but before any use of the result.  In that case, the overflowed
computation is benign.  Below is such an example.  Even the
multiplication $x \times_u y$ overflows, the product \cc{size} is
not used before the check.
\input{code/error-before-use}

To avoid warning against such cases, \sys invokes LLVM to push every
integer operation down to the latest possible point along the control
flow, so that the result is computed only when it is needed.  The
detail of the algorithm is omitted since it is similar to load
hoisting, except that it runs towards the opposite direction, and
does not need to consider memory loads and stores.

In the above example, \sys will move the integer operation $x
\times_u y$ down to right after the \cc{if} branch and before the
\cc{malloc} call, where its result \cc{size} is first used.

\paragraph{Error checking idiom.}

We notice that when generating path constraints some integer
operations like division would significantly slow down the constraint
solver~\cite{brummayer:perf}.  Many of such cases are used in integer
error checks like $N /_u x > y$, where $N$ is a constant and $x,
y$ are $n$-bit integers.  \sys recognizes such an integer error
checking idiom and rewrites it to avoid the division operation, as
follows.

In general, \sys first zero-extends $x$ and $y$ from $n$ to $2n$
bits, as $x_{2n}$ and $y_{2n}$, respectively, and rewrites the check
as multiplication $x_{2n} \times_u y_{2n} <_u N$.  If $N$ is a
special constant, such as $\uintmax(n)$ or $2^n-1$, \sys rewrites
the check with the multiplication overflow detection circuit (see
\autoref{s:gen:err}).

\autoref{f:udiv} shows a microbenchmark that measures the solving
time of the three checking forms of 32- and 64-bit integers,
respectively.  Each test is repeated 1000 times.  For a single
unsigned division operation this optimization can achieve up to
2.5$\times$ speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of $\uintmax(n) /_u x > y$ and two variant
forms: $2n$-bit multiplication and the multiplication overflow
detection circuit, measured in milliseconds.}
\label{f:udiv}
\end{figure}

\subsection{Limitations}

\sys will miss the following integer errors.

\sys only understands C-language code; it will cannot detect integer
errors written in assembly language.

\sys cannot scan code that is not enabled for compilation in the
testing configuration or architecture.  For better code coverage
one may enable as many modules as possible, or try cross compilation
for different architectures.

As discussed in \autoref{s:sema}, \sys will miss integer errors
that is not modeled by its semantics.  Particularly, it cannot catch
overflows if the developer uses left shift instead of multiplication;
its default semantics may not apply to some architectures like
PowerPC and will miss bugs specific to those architectures;

\sys analyzes loops by unrolling them once, so it will miss integer
errors caused by looping, for example, an addition overflow in an
accumulation.

\sys's alias assumption is unsound, and thus it will miss bugs
caused by the assumption.

Finally, if the solver times out, \sys will miss the possible integer
error corresponding to the queried constraint.
