\section{Design}
\label{s:gen}

This section describes \sys's design for constraint generation and
solving.  The archive scalability, \sys chooses function an appropriate
granularity for constraint generation.  The constraint generation
algorithms are designed to inspect one function at a time, so as
to bound the size of constraints.

To improve accuracy, \sys allows users to annotate the ranges of
variables, such as function parameters and structure fields, as
additional constraints. It also employs a whole-program pass that
infers the range constraints across the call graph.

\subsection{Transformations}

\sys performs a series of code transformations for better constraint
generation.  As discussed in \autoref{s:goal}, these transformations
should not destroy the semantics of integer security.

\paragraph{Pointer arithmetic simplification.}
- symbolic~\cite{engelen:symbolic}.

\paragraph{Value equality testing.}
How to determine the values from two load instructions
are the same? Load hoisting, unsound aliasing rules.

\autoref{f:hoist} shows in the hoisting algorithm.

\begin{figure}
\footnotesize
\input{algo/hoist}
\caption{The hoisting algorithm to move a load instruction to the
earliest possible point within a function.  It repeats the two
phases: first try to move the instruction to the beginning of its
basic block; if successful, try to move it into the common ancestor
of the block's predecessors.}
\label{f:hoist}
\end{figure}

\paragraph{Error-before-check.}
An integer error check may come after the overflowed computation,
but before any use of the result.  In that case, the overflowed
computation is benign.  Below is such an example.  Even the
multiplication $x \times_u y$ overflows, the product \cc{size} is
not used before the check.
\input{code/error-before-use}

To avoid warning against such caees, \sys invokes LLVM to push every
integer operation down to the latest possible point along the control
flow, so that the result is computed only when it is needed.  The
detail of the algorithm is omitted since it is similar to load
hoisting, except that it runs towards the opposite direction, and
does not need to consider memory loads and stores.

In the above example, \sys will move the integer operation $x
\times_u y$ down to right after the \cc{if} branch and before the
\cc{malloc} call, where its result \cc{size} is first used.

\paragraph{Overflowed checking idiom.}
It is commonly seen in practice to use an overflowed result to do
the integer error check for $x +_u y$, where $x$ and $y$ are
of type \cc{unsigned int}, as follows.
\begin{align}
x +_u y <_u x.
\end{align}
This is equivalent to a ``sane'' check
$\cc{UINT_MAX} - x >_u y$.

Note that using overflowed result to check multiplication is trickier.
In general $x \times_u y <_u x$ is not a valid integer error check
but a bug.  [[[XXX: use the running example?]]]
A correct way would be $(x \times_u y) /_u y \neq x$
or a sane check, $\cc{UINT_MAX} /_u x > y$.

\sys recognizes XXX integer error checking idioms...

\subsection{Error Constraint Generation}

\paragraph{Conversion constraint.}
\sys by default does not generate constraints for checking integer
conversions.  One may simply invoke GCC with \cc{-Wconversion} to
inspect potentially dangerous conversions.
[[[\sys does something for critical integers, array indices, annotated sizes.]]]

\paragraph{In-loop constraint.}
Move in-loop constraints out.

\subsection{Path Constraint Generation}

Path constraint generation.

unroll loops once.

\subsection{Value Range Inference}

Range constraint \& annotations?

\subsection{Limitations}

miss bugs in some configurations, architectures,
and assembly code.
