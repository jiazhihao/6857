\section{Design}
\label{s:gen}

\autoref{f:flow} shows \sys's workflow.  Given the LLVM intermediate
representation~(IR) compiled from source code, \sys generates a set
of constraints for each integer operation, and feed them into the
Boolector constraint solver for deciding satisfiability.

Specifically, \sys generates three types of constraints.
%
Given an integer operation, the error constraint is generated
directly from definition.
%
\sys also calculates the path constraint, the predicate satisfying
which the operation is reachable from the start of that function.
%
To further improve accuracy, \sys infers additional range information
of function parameters and structure fields across the call graph,
and allows users to provide range annotations.

\begin{figure}
\centering
\resizebox{0.9\linewidth}{!}{
\input{figs/flow}
}
\caption{\sys's workflow.  It generates constraints from the LLVM
intermediate representation~(IR) and user annotations, and then feeds
the constraints to a solver for satisfiability testing.}
\label{f:flow}
\end{figure}

\subsection{Error Constraint Generation}

For arithmetic and shift operations, it is straightforward to
generate the error constraints from their definitions shown in
\autoref{s:sema:constr}.  Boolector provides highly optimized Boolean
circuits for implementing these error constraints.  As for $n$-bit
unsigned multiplication, a simple solution is to implement a $2n$-bit
binary multiplier, which flags an overflow error if any of the most
significant $n$ bits of the product is 1; Boolector's overflow
detection circuit does not even need to compute the $2n$-bit product
and thus can be solved more
efficiently~\cite[\chapterautorefname~3.5]{brummayer:phd}.  \sys
reuses these circuits for better performance.

According to \autoref{s:sema:constr}, \sys deals with conversions as follows.

\sys derives a predicate from each comparison.  If the predicate
is trivially true or false resulted from a conversion, \sys reports
the conversion as an integer error.

Though it is easy to generate the error constraint for a value $x$
that should be non-negative, i.e., $x <_s 0$, \sys needs to know
them first.  \sys requires annotations on ``size'' function parameters.
As for the Linux kernel, we annotate parameters in functions like
\cc{memcpy}, \cc{copy_from_user}, and \cc{sock_alloc_send_skb}.
\sys also implements a front-end plugin to annotate array indices.

\subsection{Path Constraint Generation}

use \autoref{f:ax25-sign} as an example.

unroll loops once.

handle comparison like \cc{p == NULL}.

\begin{figure}
\input{algo/path}
\caption{Algorithm for path constraint generation.}
\label{f:path-cstr}
\end{figure}

\subsection{Range Constraint Generation}

Range constraint \& annotations?

handle sysctl interface.


\subsection{Optimization}

[[[Move in-loop constraints out.]]]

\paragraph{Pointer arithmetic.}
\sys represents each pointer or memory address as a symbolic
expression~\cite{engelen:symbolic}, and tries to simplify it if
possible.  A pointer expression that \sys fails to simplify will
be considered as a black-box integer, which can be any value within
its range.  Consider the code snippet below.
%
\input{code/pid-ptrsub}
%
The offset of \cc{pidmap} in the structure \cc{pid_namespace} is 4
bytes, i.e., the size of \cc{kref}, thus \sys represents the address
\cc{pid_ns->pidmap} as $\cc{pid_ns} + 4$.  Here \cc{pid_ns} is
considered as a black box since no further information is available.

In addition, assuming the size of each element of \cc{pidmap} is 8
bytes, \sys represents the address \cc{\&pid_ns->pidmap[i]} as
$\cc{pid_ns} + 4 + i \times 8$; in this example we have $i =
(\cc{last} + 1) /_u \cc{BITS_PER_PAGE}$.  Thus, the value of \cc{off},
the subtraction of the two pointers, is reduced to $(\cc{pid_ns} +
4 + i \times 8) - (\cc{pid_ns} + 4) = i \times 8$.

\paragraph{Value equality testing.}
How to determine the values from two load instructions
are the same? Load hoisting, unsound aliasing rules.

\autoref{f:hoist} shows in the hoisting algorithm.

aliasing assumption~\cite{livshits:ipssa}.
\sys assumes that a pointer passed as a function parameter or a
global variable points is distinct from any other memory location.


\begin{figure}
\input{algo/hoist}
\caption{The hoisting algorithm to move a load instruction to the
earliest possible point within a function.  It repeats the two
phases: first try to move the instruction to the beginning of its
basic block; if successful, try to move it into the common ancestor
of the block's predecessors.}
\label{f:hoist}
\end{figure}

\paragraph{Error-before-check.}
An integer error check may come after the overflowed computation,
but before any use of the result.  In that case, the overflowed
computation is benign.  Below is such an example.  Even the
multiplication $x \times_u y$ overflows, the product \cc{size} is
not used before the check.
\input{code/error-before-use}

To avoid warning against such cases, \sys invokes LLVM to push every
integer operation down to the latest possible point along the control
flow, so that the result is computed only when it is needed.  The
detail of the algorithm is omitted since it is similar to load
hoisting, except that it runs towards the opposite direction, and
does not need to consider memory loads and stores.

In the above example, \sys will move the integer operation $x
\times_u y$ down to right after the \cc{if} branch and before the
\cc{malloc} call, where its result \cc{size} is first used.

\paragraph{Overflowed checking idiom.}

\sys recognizes XXX integer error checking idioms...

\subsection{Limitations}

miss bugs in some configurations, architectures,
and assembly code.
