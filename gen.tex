\section{Design}
\label{s:gen}

This section describes \sys's design for constraint generation and
solving.

\subsection{Transformations}

\sys performs a series of code transformations for better constraint
generation.  As discussed in \autoref{s:goal}, these transformations
should not destroy the semantics of integer security.

\paragraph{Value equality testing.}
How to determine the values from two load instructions
are the same? Load hoisting, unsound aliasing rules.

\autoref{f:hoist} shows in the hoisting algorithm.

\begin{figure}
\footnotesize
\input{algo/hoist}
\caption{The hoisting algorithm to move a load instruction to the
earliest possible point within a function.  It repeats the two
phases: first try to move the instruction to the beginning of its
basic block; if successful, try to move it into the common ancestor
of the block's predecessors.}
\label{f:hoist}
\end{figure}

\paragraph{Overflow-before-check.}
\sys invokes LLVM to push every integer operation to the latest
possible point, so that the result is computed only when it is
needed.

\paragraph{Checking idiom recognition.}

\paragraph{Pointer arithmetic simplification.}
- symbolic~\cite{engelen:symbolic}.

\subsection{Error Constraint Generation}

\paragraph{Conversion constraint.}
\sys by default does not generate constraints for checking integer
conversions.  One may simply invoke GCC with \cc{-Wconversion} to
inspect potentially dangerous conversions.
[[[\sys does something for critical integers, array indices, annotated sizes.]]]

\paragraph{In-loop constraint.}
Move in-loop constraints out.

\subsection{Path Constraint Generation}

Path constraint generation.

unroll loops once.

\subsection{Value Range Inference}

Range constraint \& annotations?

\subsection{Limitations}

miss bugs in some configurations, architectures,
and assembly code.
