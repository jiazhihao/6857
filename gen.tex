\section{Design}
\label{s:gen}

\autoref{f:flow} shows \sys's workflow.  Given the LLVM intermediate
representation~(IR) compiled from source code, \sys generates a set
of constraints for each integer operation, and feed them into the
Boolector constraint solver for deciding satisfiability.

Specifically, \sys generates three types of constraints.
%
Given an integer operation, the error constraint is generated
directly from definition.
%
\sys also calculates the path constraint, the predicate satisfying
which the operation is reachable from the start of that function.
%
To further improve accuracy, \sys infers additional range information
of function parameters and structure fields across the call graph.
It also allows users to provide annotations as constraints.

\begin{figure}
\centering
\resizebox{\linewidth}{!}{
\input{figs/flow}
}
\caption{\sys's workflow.  It generates constraints from the LLVM
intermediate representation~(IR) and user annotations, and then feeds
the constraints to a solver for satisfiability testing.}
\label{f:flow}
\end{figure}

\subsection{Error Constraint Generation}

For arithmetic and shift operations, it is straightforward to
generate their error constraints from their definitions shown in
\autoref{s:sema:constr}.  As for $n$-bit unsigned multiplication,
one may use a $2n$-bit binary multiplier (extending both integers
from $n$ to $2n$ bits first), which flags an overflow error if any
of the most significant $n$ bits of the product is
1~\cite{molnar:catchconv}.

Boolector provides highly optimized Boolean circuits for implementing
some of these error constraints.  Its overflow detection circuit,
for example, does not even need to compute the $2n$-bit product and
thus can be solved far more
efficiently~\cite[\chapterautorefname~3.5]{brummayer:phd}.  \sys
reuses these circuits for better performance.

\sys deals with the two conversion cases as follows.

To detect tautological comparisons, \sys derives a predicate from
each comparison.  If the predicate is trivially true or false
resulted from an integer conversion within that function, \sys
reports the conversion as an integer error.

For negative counts, it is easy to generate the error constraint
for a value $x$ that should be conceptually non-negative, that is,
$x <_s 0$; however, \sys needs to know them first.  \sys implements
a front-end plugin to recognize array indices.  \sys also requires
user-provided annotations on ``size'' function parameters.  As for
the Linux kernel, we annotate parameters in functions like \cc{memcpy},
\cc{copy_from_user}, and \cc{sock_alloc_send_skb}.

\subsection{Path Constraint Generation}

We use \autoref{f:ax25-sign} as an example to illustrate how \sys
generates path constraints.  The control flow of the code is shown
in \autoref{f:cfg}, where there are two sanity checks on \cc{optlen}
before it reaches \cc{copy_from_user}.  For clarification purpose
\cc{optlen} is numbered every time it is assigned a new
value~\cite[\chapterautorefname~8.11]{whale}.  Our goal is to
evaluate the path constraint for the call to \cc{copy_from_user}.

The basic algorithm works as follows.  Since there is no loop, the
path constraint of the call to \cc{copy_from_user} is simply the
logical OR of the constraint from each of its predecessors, namely
\textsc{If-True} and \textsc{If-False}.  For each predecessor, the
constraint is a logical AND of three parts: the branching condition,
possible assignment(s) in the predecessor, and the path constraint
of that predecessor.  Here both \textsc{If-True} and \textsc{If-False}
unconditionally jump to \cc{copy_from_user}, so their branching
conditions are simply true, which can be ignored.  Now we have the
path constraint as follows:
\newcommand{\optlen}{{\small \texttt{optlen}}}
\newcommand{\pc}{\textrm{PathConstraint}}
%
\begin{align*}
& ((\optlen_1 = 16) \land \pc(\textsc{If-True})) \\
\lor & ((\optlen_1 = \optlen_0) \land \pc(\textsc{If-False})).
\end{align*}

Recursively apply the algorithm to \textsc{If-True} and \textsc{If-False},
and we can get the fully expanded result:
%
\begin{align*}
& ((\optlen_1 = 16) \land (\optlen_0 >_s 16)
    \land \neg(\optlen_0 <_u 4)) \\
\lor & ((\optlen_1 = \optlen_0) \land \neg(\optlen_0 >_s 16) \\
     & \; \land \neg(\optlen_0 <_u 4)).
\end{align*}

One can feed the logical AND of the path constraint and the error
constraint (i.e., $\cc{optlen}_1 <_s 0$) into the solver, which
will reply with an error example, e.g., $\cc{optlen}_0 = -1$.

\begin{figure}
\centering
\resizebox{\linewidth}{!}{
\input{figs/cfg}
}
\caption{The control flow of the code snippet in \autoref{f:ax25-sign}.}
\label{f:cfg}
\end{figure}

For complex programs that contain loops, \sys handles them using
the standard unrolling technique~\cite{xie:saturn}.  The path
constraint generation algorithm unrolls each loop once and ignores
branching edges that jump back in the control flow, aka back edges.
See the complete algorithm in \autoref{f:path-cstr}.

\begin{figure}
\input{algo/path}
\caption{Algorithm for path constraint generation.}
\label{f:path-cstr}
\end{figure}

\subsection{Range Constraint Generation}

Range constraint \& annotations?

handle sysctl interface.


\subsection{Optimizations}

\paragraph{In-loop constraint.}

\paragraph{Pointer arithmetic.}
\sys represents each pointer or memory address as a symbolic
expression~\cite{engelen:symbolic}, and tries to simplify it if
possible.  A pointer expression that \sys fails to simplify will
be considered as a black-box integer, which can be any value within
its range.  Consider the code snippet below.
%
\input{code/pid-ptrsub}
%
The offset of \cc{pidmap} in the structure \cc{pid_namespace} is 4
bytes, i.e., the size of \cc{kref}, thus \sys represents the address
\cc{pid_ns->pidmap} as $\cc{pid_ns} + 4$.  Here \cc{pid_ns} is
considered as a black box since no further information is available.

In addition, assuming the size of each element of \cc{pidmap} is 8
bytes, \sys represents the address \cc{\&pid_ns->pidmap[i]} as
$\cc{pid_ns} + 4 + i \times 8$; in this example we have $i =
(\cc{last} + 1) /_u \cc{BITS_PER_PAGE}$.  Thus, the value of \cc{off},
the subtraction of the two pointers, is reduced to $(\cc{pid_ns} +
4 + i \times 8) - (\cc{pid_ns} + 4) = i \times 8$.

\paragraph{Value equality testing.}
How to determine the values from two load instructions
are the same? Load hoisting, unsound aliasing rules.

%\autoref{f:hoist} shows in the hoisting algorithm.

aliasing assumption~\cite{livshits:ipssa}.
\sys assumes that a pointer passed as a function parameter or a
global variable points is distinct from any other memory location.


\if 0
\begin{figure}
\input{algo/hoist}
\caption{The hoisting algorithm to move a load instruction to the
earliest possible point within a function.  It repeats the two
phases: first try to move the instruction to the beginning of its
basic block; if successful, try to move it into the common ancestor
of the block's predecessors.}
\label{f:hoist}
\end{figure}
\fi

\paragraph{Error-before-check.}
An integer error check may come after the overflowed computation,
but before any use of the result.  In that case, the overflowed
computation is benign.  Below is such an example.  Even the
multiplication $x \times_u y$ overflows, the product \cc{size} is
not used before the check.
\input{code/error-before-use}

To avoid warning against such cases, \sys invokes LLVM to push every
integer operation down to the latest possible point along the control
flow, so that the result is computed only when it is needed.  The
detail of the algorithm is omitted since it is similar to load
hoisting, except that it runs towards the opposite direction, and
does not need to consider memory loads and stores.

In the above example, \sys will move the integer operation $x
\times_u y$ down to right after the \cc{if} branch and before the
\cc{malloc} call, where its result \cc{size} is first used.

\paragraph{Overflowed checking idiom.}

\sys recognizes XXX integer error checking idioms...

\subsection{Limitations}

miss bugs in some configurations, architectures,
and assembly code.
