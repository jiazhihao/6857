\section{Design}
\label{s:gen}

To find integer errors, \sys first compiles the C source code to the
LLVM intermediate representation~(IR).  \sys then examines the IR to
find integer operations, and for each operation, \sys generates a
set of predicates on the program's variables that would have to be
true in order for that integer operation to have an error.  Finally,
\sys feeds the predicates for each integer operation into the
Boolector constraint solver for deciding satisfiability.  If the
solver answers ``satisfiable'' with an assignment of variables,
there is a potential integer error that could be triggered with
that assignment.  This workflow is shown in \autoref{f:flow}.

The key challenge is to reduce the complexity of these predicates,
so that the solver can run efficiently.  This section describes how
\sys generates the predicates.

\begin{figure}
\centering
\resizebox{\linewidth}{!}{
\input{figs/flow}
}
\caption{\sys's workflow.  It generates predicates from the LLVM
intermediate representation~(IR) and user annotations, and then feeds
the predicates to a solver for satisfiability testing.}
\label{f:flow}
\end{figure}

\subsection{Out-of-Bounds Predicate Generation}
\label{s:gen:oob}

To find integer errors, \sys must detect integer operations
that violate the corresponding in-bounds requirements, as listed
in \autoref{f:in-bounds}.  To do so, for each integer operation
\sys derives the negation of its in-bounds requirement, namely
the out-of-bounds~(OOB) predicate, satisfying which implies an error.

\paragraph{Addition, subtraction, and multiplication.}
The Boolector constraint solver provides an API for constructing
efficient overflow detection
predicates~\cite[\subsectionautorefname~3.5]{brummayer:phd}.
\sys invokes the API to generate OOB predicates for additive and
multiplicative operations.

\paragraph{Division.}
For signed division $x /_s y$, \sys generates the OOB predicate
$y = 0 \lor (x = -2^{n-1} \land y = -1)$.
For unsigned division $x /_u y$, the OOB predicate is simply
$y = 0$.

\if 0
Take multiplication for an example.  Given two $n$-bit unsigned
integers $x$ and $y$, the in-bounds requirement is that their product
cannot overflow $\uintmax(n)$.  There are several possible OOB
predicates \sys could generate.
A \naive form is:
\begin{equation*}
x \neq 0 \land \uintmax(n) /_u x > y.
\end{equation*}
Another possible predicate is to use a $2n$-bit
multiplier~\cite{molnar:catchconv}: extend $x$ and $y$ to $2n$ bits
and flag an error if any of the most significant $n$ bits of the
product is 1.  This is conceptually equivalent to:
\begin{equation*}
x_{2n} \times y_{2n} > \uintmax(n).
\end{equation*}
Both forms would hurt the solver's performance noticeably.
%
\sys reuses a specialized multiplication overflow detection predicate
from the Boolector constraint
solver~\cite[\chapterautorefname~3.5]{brummayer:phd}, which can be
solved far more efficiently without computing the product.  The
detailed implementation of the predicate is beyond the scope of
this paper.
\fi

\paragraph{Shift.}
The OOB predicate \sys generates for an $n$-bit shift
$x \shl y$ or $x \shr y$ is a simple comparison $y \geq_u n$.

\paragraph{Conversion.}
As defined \autoref{s:sema:sec}, \sys deals with conversions
in the following cases.

To detect tautological comparisons, \sys derives a predicate from
each comparison.  If the predicate is trivially true or false,
and results from an integer conversion within that function, \sys
reports the conversion as an integer error.

For an array index $x$, \sys generates an OOB predicate $x <_s 0$.
\sys implements a front-end plugin to recognize array indices.

For a data size $x$, \sys generates an OOB predicate $x <_s 0$.
We annotate the ``size'' parameters in functions 
like \cc{memcpy}, \cc{copy_from_user}, and \cc{sock_alloc_send_skb} in
the Linux kernel as data sizes for \sys.

\subsection{Path Predicate Generation}
\label{s:gen:path}

\sys generates a path predicate for each integer operation, which encodes
the constraints on the variables that arise from preceding operations
in the function's control flow.  These constraints arise from two general
sources: assignments to variables by preceding operations, and conditional
branches along the execution path.  Satisfying the path predicate with
a set of variable assignments means that the integer operation is
reachable from the beginning of the function with the given variable values.
The path predicate is used to filter out integer errors that cannot
happen due to previous statements in a function, such as assignments or
explicit overflow checks.

\begin{figure}
\centering
\resizebox{\linewidth}{!}{
\input{figs/cfg}
}
\caption{The control flow of the code snippet in \autoref{f:ax25-sign}.}
\label{f:cfg}
\end{figure}

Let us consider loop-free programs first.
%
We use the code in \autoref{f:ax25-sign} as an example.  The control flow of
the code is shown in \autoref{f:cfg}.  There are two sanity checks
on \cc{optlen} before it reaches the call to \cc{copy_from_user}.
For clarification purposes, \cc{optlen} is renumbered every time it is
assigned a new value~\cite[\subsectionautorefname~8.11]{whale}.  Our
goal is to evaluate the path predicate for the call to \cc{copy_from_user}.

The basic algorithm works as follows.  Since there is no loop, the
path predicate of the call to \cc{copy_from_user} is simply the
logical OR of the predicates from each of its predecessors, namely
\textsc{If-True} and \textsc{If-False}.  For each of those two blocks,
the predicate is a logical AND of three parts: the branching condition
(for the transition from that block to \cc{copy_from_user}), the
assignment(s) in that block, and the path predicate
of that block.  Both \textsc{If-True} and \textsc{If-False}
unconditionally jump to \cc{copy_from_user}, so their branching
conditions are simply true, which can be ignored.  Now we have the
following path predicate:
\newcommand{\optlen}{{\small \texttt{optlen}}}
\newcommand{\pc}{\textrm{PathPredicate}}
%
\begin{align*}
& ((\optlen_1 = 16) \land \pc(\textsc{If-True})) \\
\lor & ((\optlen_1 = \optlen_0) \land \pc(\textsc{If-False})).
\end{align*}

By recursively applying the same algorithm to \textsc{If-True} and
\textsc{If-False}, we obtain the fully expanded result:
%
\begin{align*}
& ((\optlen_1 = 16) \land (\optlen_0 >_s 16)
    \land \neg(\optlen_0 <_u 4)) \\
\lor & ((\optlen_1 = \optlen_0) \land \neg(\optlen_0 >_s 16) \\
     & \; \land \neg(\optlen_0 <_u 4)).
\end{align*}

After computing the path predicate, \sys feeds the logical AND of the
path predicate and the OOB predicate (i.e., $\cc{optlen}_1 <_s 0$) into
the solver to determine whether the integer operation can have an error.
In this case, the solver will reply with an assignment that triggers
the error: for example, $\cc{optlen}_0 = -1$.

For programs that contain loops, the path predicate generation algorithm
unrolls each loop once and ignores branching edges that jump back in the
control flow~\cite{xie:saturn}. This approach limits the growth of complexity
of the path predicate, and thus sacrifices soundness for performance.  
The complete algorithm is shown in \autoref{f:path-cstr}.

\begin{figure}
\input{algo/path}
\caption{Algorithm for path predicate generation.}
\label{f:path-cstr}
\end{figure}

To partially alleviate missing predicates due to loop unrolling,
\sys tries to move predicates inside a loop to the outer scope,
and substitutes the loop variable in the predicate with its exit value.
Consider the following loop.
\input{code/loop}
\sys generates an OOB predicate $i <_s 0$ since $i$ is used
as an array index.  Simply unrolling the loop once (i.e., $i = 0$)
would make a false predicate $0 <_s 0$, which might miss a possible
integer error (e.g., if the code does not correctly restrict $n$).
To address the problem, \sys generates a new predicate $n <_s 0$
outside the loop, by substituting the loop variable $i$ with its
exit value $n$ in the predicate $i <_s 0$.

\subsection{Range Predicate Generation}
\label{s:gen:range}

OOB and path predicates are generated on a per-function basis.
Tracking symbolic predicates across functions can lead to solving complex
constraint expressions, which would not scale to a large system such as the
Linux kernel.

To address the scalability issue, when generating predicates across functions
(i.e., for entities like function parameters, return values, global variables,
and structure members), \sys bounds each integer-typed entity using a simpler
form of constraints: two constant
integers as the minimum and maximum values, respectively. For example, if the
value of a parameter $x$ ranges from 1 to 10, \sys generates the range
predicates $x \geq 1 \land x < 11$.

\sys keeps a range for each cross-function entity in a global
range table.  Initially, \sys sets the ranges of untrusted entities
(e.g., system call parameters, see \autoref{s:rank:input}) to full
sets and the rest to empty.  Then it updates their ranges iteratively,
until the ranges converge, or simply set the ranges to full sets
after a limited number of rounds.

The iteration works as follows.
\sys scans through every function of the entire code base. When encountering
accesses to a cross-function entity, such as loads from a structure member or a
global variable, \sys retrieves the entity's value range from the global range
table.  Within a function, \sys propagates value ranges using range
arithmetic~\cite{range-analysis}.  When a value reaches an external sink
through argument passing, function returns, stores to structure members or
global variables, the corresponding range table entry is updated by merging its
previous range with the range of the incoming value.

To propagate ranges across functions, \sys requires a system-wide
call graph.  To do so, \sys builds the call graph iteratively. For
each indirect call site (i.e., function pointers), \sys collects
possible target functions from initialization code and stores to
the function pointer.

\sys refines ranges using
domain-specific knowledge. For example, many \cc{sysctl} parameters in the
Linux kernel have lower and upper bounds encoded in the initialization code of
their \cc{sysctl} table entries.  \sys recognizes the \cc{sysctl} table
structures and extracts the bounds accordingly.


\subsection{Code Rewriting}
\label{s:gen:opt}

In order to reduce false errors and to improve performance,
\sys performs a series of code transformations on the 
generated LLVM IR\@.

\paragraph{Pointer arithmetic.}
\sys represents each pointer or memory address as a symbolic
expression~\cite{engelen:symbolic}, and tries to simplify it if
possible.  \sys considers a pointer expression that it fails to simplify
as an unconstrained integer, which can be any value within its range.
Consider the following code snippet:
%
\input{code/pid-ptrsub}
%
\if 0
The offset of \cc{pidmap} in the structure \cc{pid_namespace} is 4
bytes (i.e., the size of \cc{kref}), thus \sys represents the address
\cc{pid_ns->pidmap} as $\cc{pid_ns} + 4$.  Here \sys considers \cc{pid_ns}
to be an unconstrained value, since no further information is available.

In addition, assuming the size of each element of \cc{pidmap} is 8
bytes, \sys represents the address \cc{\&pid_ns->pidmap[i]} as
$\cc{pid_ns} + 4 + i \times 8$; in this example we have $i =
(\cc{last} + 1) /_u \cc{BITS_PER_PAGE}$.  Thus, the value of \cc{off},
the subtraction of the two pointers, is reduced to $(\cc{pid_ns} +
4 + i \times 8) - (\cc{pid_ns} + 4) = i \times 8$.
%
Without this rewriting, \sys would have considered \cc{off} to be
the result of a subtraction between two unconstrained integers, and
would have reported an error.
\fi

Assume that the offset into the structure member \cc{pidmap[]} is 4 bytes, 
and the size of its element is 8 bytes.
%
The symbolic expression for \cc{map} and \cc{pid_ns->pidmap} would
be $\cc{pid_ns} + 4 + i \times 8$ and $\cc{pid_ns} + 4$ respectively,
where the array index $i = (\cc{last} + 1) /_u \cc{BITS_PER_PAGE}$.

Thus, the value of \cc{off}, the subtraction of the two pointers, 
can be reduced to $(\cc{pid_ns} + 4 + i \times 8) - (\cc{pid_ns} + 4) 
= i \times 8$, which is irrelevant to the value of pointer \cc{pid_ns}.
Without this rewriting, \sys would have considered \cc{off} to be
the result of a subtraction between two unconstrained integers, and
would have flagged an error.

\paragraph{Memory model.}
\sys employs a simple memory model: a value returned from a load
instruction is unconstrained~(unless the value has a range predicate).
To reduce false errors, \sys merges load instructions from the same
pointer.
Consider the example below.
\input{code/alias}
The code correctly limits \cc{arg->count} to avoid multiplication
overflows.  However, since each occurrence of \cc{arg->count} means
a load from memory, \sys would report false errors for \cc{arg->count
* sizeof(int)}, since it considers the value from the load for
\cc{arg->count} unconstrained.  Therefore, \sys must merge these
load instructions for \cc{arg->count}.

LLVM's load elimination algorithm is too conservative and does not
fit our goal.  For the above example, it conservatively
assumes that the call to \cc{kmalloc} \emph{may} modify \cc{arg->count}
(e.g., via some global variable that points to \cc{arg}),
and thus cannot merge the \cc{arg->count} in \cc{copy_from_user}
with the others.

\sys merges load instructions as follows.
It first adopts an unsound assumption: a pointer passed to a
function argument or a global variable points to a memory location
that is distinct from any other pointers.  This assumption
has been proven to be practical for detecting bugs
in C programs~\cite{livshits:ipssa}.
%
In the example, \sys assumes that \cc{kmalloc} cannot hold a pointer
to \cc{arg}, and concludes that the call to \cc{kmalloc} does
not modify \cc{arg->count}.

\sys then hoists every load instruction to
the earliest possible point within the function.  The hope is that
those load instructions will be moved up and put close to each
other, so that \sys can easily merge identical ones.
%
Consider a load instruction $L$ that loads from pointer $p$.  $L$ is
safe to move across its previous instruction $I$ if:
\begin{CompactItemize}
\item $I$ does not write to any memory location, or
\item $I$ writes to pointer $q$, and $p$ and $q$ never point to the
same memory location (i.e., they do not alias).
\end{CompactItemize}

If $L$ is already the first instruction in a non-entry block and
there are multiple predecessors that jump to $I$, \sys tries to
move $L$ up to their common ancestor block.  \sys repeatedly hoists $L$
until it is either unsafe to do so or $L$ reaches the entry block of the
function.

In practice, \sys's memory model avoids sophisticated global
analysis and achieves good performance (see \autoref{s:eval:perf}).

\if 0
\begin{figure}
\input{algo/hoist}
\caption{The hoisting algorithm to move a load instruction to the
earliest possible point within a function.  It repeats the two
phases: first try to move the instruction to the beginning of its
basic block; if successful, try to move it into the common ancestor
of the block's predecessors.}
\label{f:hoist}
\end{figure}
\fi

\paragraph{Error-before-check.}
An integer error check may occur after the overflowed computation,
but before any use of the result.  In that case, the overflowed
computation is benign.  In the following example, even if the
multiplication $x \times_u y$ overflows, the product \cc{size} is
not used before the check.
\input{code/error-before-use}

To avoid generating a warning in such cases, \sys pushes every
integer operation down to the latest possible point along the control
flow, so that the result is computed only when it is needed.  The
details of this algorithm are omitted since it is similar to load
hoisting, except that it pushes code in the opposite direction, and
does not need to consider memory loads and stores.

In the above example, \sys will move the integer operation $x
\times_u y$ down to right after the \cc{if} branch and before the
\cc{malloc} call, where its result \cc{size} is first used.

\paragraph{Error checking idiom.}

Some integer operations such as division in path predicates can
significantly slow down the constraint solver~\cite{brummayer:perf}.
Many such cases occur in integer error checks like $\cc{if}\ (N /_u
x > y)$, where $N$ is a constant and $x$ and $y$ are $n$-bit integers.
\sys recognizes such idioms and rewrites them to avoid the slow
operations.

For example, to avoid division in $N /_u x > y$, \sys rewrites the check using
Boolector's multiplication overflow detection predicate described
in \autoref{s:gen:oob}, provided that $N$ equals $\uintmax(n)$.
Otherwise \sys rewrites the check using multiplication as $x_{2n}
\times_u y_{2n} >_u N$, where $x_{2n}$ and $y_{2n}$ are zero-extension
of $x$ and $y$ from $n$ to $2n$ bits, respectively.

\subsection{Limitations}
\label{s:gen:limit}

\sys will miss the following integer errors.
%
\sys only understands code written in C; it cannot detect integer
errors written in assembly language.
%
\sys cannot scan code that is not enabled for compilation in the
testing configuration or architecture.  For better code coverage,
one should enable as many modules as possible, or try cross compilation
for different architectures.

\sys will miss integer errors
that are not modeled by its semantics.  Particularly, it cannot catch
overflows if the developer uses left shift instead of multiplication
(see \autoref{s:sema:sec});
it will also miss errors specific to architectures like PowerPC,
whose semantics it does not model~(see \autoref{s:sema:def})

If the annotations for ``size'' parameters are incomplete, \sys will
miss the corresponding integer errors.

\sys analyzes loops by unrolling them once, so it will miss integer
errors caused by looping, for example, an addition overflow in an
accumulation.

\sys's alias assumption is unsound, and thus it will miss errors
caused by the assumption.

Finally, if the solver times out, \sys will miss the possible integer
error corresponding to the queried predicates.
