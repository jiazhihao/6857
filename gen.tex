\section{Design}
\label{s:gen}

To find integer errors, \sys first compiles the C source code to the
LLVM intermediate representation~(IR).  \sys then examines the IR to
find integer operations, and for each operation, \sys generates a
set of predicates on the program's variables that would have to be
true in order for that integer operation to have an error.  Finally,
\sys feeds the predicates for each integer operation into the
Boolector constraint solver for deciding satisfiability.  If the
solver answers ``satisfiable'' with an assignment of variables,
there is a potential integer error that could be triggered with
that assignment. 

The key challenge is to reduce the complexity of these predicates,
so that the solver can run efficiently.  This section describes how
\sys generates the predicates.

To find integer errors, \sys must detect integer operations
that violate the corresponding in-bounds requirements, as listed
in \autoref{f:in-bounds}.  To do so, for each integer operation
\sys derives the negation of its in-bounds requirement, namely
the out-of-bounds~(OOB) predicate, satisfying which implies an error.

\paragraph{Addition, subtraction, and multiplication.}
The Boolector constraint solver provides an API for constructing
efficient overflow detection
predicates~\cite[\subsectionautorefname~3.5]{brummayer:phd}.
\sys invokes the API to generate OOB predicates for additive and
multiplicative operations.

\paragraph{Division.}
For signed division $x /_s y$, \sys generates the OOB predicate
$y = 0 \lor (x = -2^{n-1} \land y = -1)$.
For unsigned division $x /_u y$, the OOB predicate is simply
$y = 0$.

Take multiplication for an example.  Given two $n$-bit unsigned
integers $x$ and $y$, the in-bounds requirement is that their product
cannot overflow $\uintmax(n)$.  There are several possible OOB
predicates \sys could generate.
A \naive form is:
\begin{equation*}
x \neq 0 \land \uintmax(n) /_u x > y.
\end{equation*}
Another possible predicate is to use a $2n$-bit
multiplier~\cite{molnar:catchconv}: extend $x$ and $y$ to $2n$ bits
and flag an error if any of the most significant $n$ bits of the
product is 1.  This is conceptually equivalent to:
\begin{equation*}
x_{2n} \times y_{2n} > \uintmax(n).
\end{equation*}
Both forms would hurt the solver's performance noticeably.
%
\sys reuses a specialized multiplication overflow detection predicate
from the Boolector constraint
solver~\cite[\chapterautorefname~3.5]{brummayer:phd}, which can be
solved far more efficiently without computing the product.  The
detailed implementation of the predicate is beyond the scope of
this project.

\paragraph{Shift.}
The OOB predicate \sys generates for an $n$-bit shift
$x \shl y$ or $x \shr y$ is a simple comparison $y \geq_u n$.

\paragraph{Conversion.}
As defined \autoref{s:sema:sec}, \sys deals with conversions
in the following cases.

To detect tautological comparisons, \sys derives a predicate from
each comparison.  If the predicate is trivially true or false,
and results from an integer conversion within that function, \sys
reports the conversion as an integer error.

For an array index $x$, \sys generates an OOB predicate $x <_s 0$.
\sys implements a front-end plugin to recognize array indices.

For a data size $x$, \sys generates an OOB predicate $x <_s 0$.
We annotate the ``size'' parameters in functions 
like \cc{memcpy}, \cc{copy_from_user}, and \cc{sock_alloc_send_skb} in
the Linux kernel as data sizes for \sys.

