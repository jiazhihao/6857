\section{Introduction}
\label{s:intro}

Integer errors, including arithmetic overflow, division-by-zero,
oversized shift, lossy truncation, and sign misinterpretation, have
emerged as a threat to systems security.  A 2007 study of the
Common Vulnerabilities and Exposures~(CVE)~\cite{cve} suggests that
they are already ``number 2 for OS vendor
advisories''~\cite{christey:vuln}, second only to buffer overflows.
Another recent survey~\cite{chen:kbugs} reviews the reported Linux kernel
vulnerabilities in the CVE from 2010 to early 2011, and confirms
the finding that integer errors account for more than one third of
the vulnerabilities that can be misused to corrupt the kernel and
gain root privilege.

\autoref{f:bridge} shows an example of an integer error in the Linux
kernel due to multiplication overflow~(CVE-2006-5751).  The size
for allocating \cc{buf} is calculated from the multiplication of
\cc{maxnum}, an integer read from user space,
and \cc{sizeof(struct __fdb_entry)}, the constant 16.  Assuming
a 32-bit platform, both \cc{maxnum} and \cc{size} are 32-bit unsigned
integers, ranging from 0 to $2^{32} - 1$.  The developer's intention
is to limit the values of \cc{maxnum} and \cc{size} to 256 and 4096,
respectively.

If an adversary supplies a large \cc{maxnum}, say $2^{31}$,
however, the multiplication $\cc{maxnum} \times 16$ would
overflow the 32-bit unsigned integer bounds and result in \cc{size}
being set to 0.  Subsequently, the sanity check $\cc{size} > 4096$
will be bypassed, so that the values of \cc{size} and \cc{maxnum}
are incorrectly limited.  In this case \cc{buf} is allocated as
a zero-length buffer; any further access into \cc{buf} is out of
bounds and may cause a kernel panic (i.e., denial-of-service).
Furthermore, the adversary may control the out-of-bounds writes
(i.e., buffer overflow) in a more elaborate way with carefully
crafted input, so as to execute arbitrary code and gain root
privilege.  A similar integer error was actually exploited
in the iOS jailbreak~\cite{esser:ios}.

Integer errors enable a spectrum of attacks.  In addition to
denial-of-service, buffer overflow, and privilege escalation
mentioned above, an integer error can also lead to information
leakage, for example, if it is used to determine the number of data
items to be sent via network, raising privacy concerns~(CVE-2009-1265).
It may cause more subtle logic bugs if the value is used in decision
making, such as misleading the kernel to kill an innocent
process~(CVE-2011-4097).

\begin{figure}[t]
\centering
\input{code/bridge}
\vspace{-1em}
\caption{An integer error in the Ethernet bridge subsystem of the
Linux kernel~(CVE-2006-5751), where a multiplication overflow
may lead to buffer overflows and allow local users to execute
arbitrary code via a large \cc{maxnum} from user space.
}
\label{f:bridge}
\end{figure}

This paper presents \sys, a compile-time tool that analyzes C-language
source code for integer errors.
%
A key challenge facing \sys is knowing what are actual integer errors.  For
example, some previous tools rigidly classify any signed-to-unsigned integer
conversion from a possibly negative value as an error~\cite{brumley:rich,
  moy:z3prefix, seacord:secure-c}; such sign conversions are so widely used in C
code that doing so would cause a flood of noisy false
errors~\cite[\subsectionautorefname~6.2]{moy:z3prefix}.  In C, a common way to
test if an integer operation overflows is using overflow; for example, to test
if \textit{base} plus \textit{len} overflows, kernel developers write
expressions such as $\mathit{base} + \mathit{len} < \mathit{base}$~\cite{ioc},
which \sys should not consider as
errors.  \sys needs integer semantics that recognize commonly used code patterns
while still effectively catch integer errors.
%Conceptually, any integer operation that may produce a
%result different from the infinitely ranged mathematical counterpart
%flags a potential integer error~\cite{air}.

A second challenge is to precisely reason about integer operations
on every code path.  Given the semantics of an integer operation,
\sys needs to determine whether the control flow can reach that
operation while simultaneously producing an out-of-bounds value.  For
example, in \autoref{f:bridge}, \sys should conclude that an overflowed
product \cc{size} will bypass the sanity check and reach the
\cc{kmalloc} call.

The final challenge is to apply \sys to large systems such as the
Linux kernel.  \sys needs to finish analyzing the source code in a
reasonable amount of time.  \sys also should rank reported integer
errors to ease human inspection.  For example, an integer error
that could only be triggered by misbehaved hardware is
less likely to receive interest than by network input.

\sys addresses these challenges with three ideas: practical integer
semantics that define integer errors, a precise analysis algorithm
that performs bit-level reasoning per function, and a set of ranking
criteria that estimate the security impacts of possible integer
errors.  \sys
%accept C source code as input, and inspects each
%integer operation for possible integer errors.
%
is implemented using the LLVM compiler framework~\cite{lattner:llvm}
and the Boolector constraint solver~\cite{boolector}.
%
%To further reduce false errors, \sys asks users to provide a white
%list of overflow checking idioms, as well as additional range
%constraint annotations to filter out infeasible cases.

The primary contributions of this paper are:
\begin{CompactItemize}
\item A design and implementation of integer error checker that has a pragmatic
  definition of integer errors and can scale to programs of the size of the
  Linux kernel;
\item An experimental evaluation in which identified \nrbugs integer errors in
  the Linux kernel, the lighttpd web server, and OpenSSH, which were confirmed
  and fixed by the developers.  It also reveals that even two previously known
  CVE cases were fixed incorrectly.  The evaluation also shows that \sys is
  complete: \sys is able to detect 34 of the 36 known integer errors in the
  Linux kernel from the past three years.
\item A few mitigation strategies, which include a new integer type that enters
  an error state once it overflows.
\end{CompactItemize}

The rest of this paper is organized as follows. \autoref{s:sema}
defines the integer semantics that \sys uses.  \autoref{s:gen}
presents \sys's design for generating constraints.  \autoref{s:rank}
describes ranking heuristics.  \autoref{s:eval} evaluates \sys using
the Linux kernel source tree and known CVE cases.
%\autoref{s:common} summarizes common integer errors
\autoref{s:miti} discusses mitigation strategies.
\autoref{s:relwk} relates \sys to previous work and \autoref{s:concl}
concludes.
