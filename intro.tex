\section{Introduction}
\label{s:intro}

Integers are fundamental data types in systems code.  Unlike
arbitrary-precision mathematical integers, they use a fixed number
of bits to represent integral values bounded by a predefined range.
An integer operation may produce a numeric value that does not fall
into the range, which could cause lost or misinterpreted data, referred
as \emph{integer errors} in this paper.  Integer errors may introduce
further logic problems and security vulnerabilities if the consequence
is unexpected.

\autoref{f:bridge} shows an example of integer errors in the Linux
kernel.  The size for allocating \cc{buf} is computed from the
multiplication of \cc{maxnum}, a variable controlled by userspace,
and \cc{sizeof(struct __fdb_entry)}, the constant 16.  Assuming
32-bit platform, both \cc{maxnum} and \cc{size} are 32-bit unsigned
integers, ranging from 0 to $2^{32} - 1$.
The developer's intention is to limit the maximum values of 
\cc{maxnum} and \cc{size} to 256 and 4096, respectively.

If an adversary supplies a large \cc{maxnum}, say \cc{0xf0000000},
the multiplication $\cc{maxnum} \times 16$ would overflow the 32-bit
unsigned integer range and result in 0.  Subsequently, the sanity
check will be bypassed and the value of \cc{maxnum} is not limited.
In this case \cc{buf} is allocated as a zero-length buffer; any
further access into \cc{buf} is out of bounds and may cause a kernel
panic (i.e., denial-of-service).  Furthermore, the adversary
may control the out-of-bounds writes (i.e., buffer overflow) in a
more elaborate way with carefully crafted input, so as to execute
arbitrary code and gain root privilege~\cite[CVE-2006-5751]{cve}.
In practice, a similar integer error was used to untether the iOS
jailbreak~\cite{esser:ios}.

Integer errors enable a spectrum of attacks.  In addition to
denial-of-service, buffer overflow, and privilege escalation we
just mentioned, a problematic integer may lead to information
leakage, for example, if it is used to determine the number of bytes
to be copied from kernel to userspace, raising privacy concerns.
It may cause more subtle logic bugs and defects if used in branching
conditions.

Integer errors have emerged as a threat to system security.  A 2007
study~\cite{christey:vuln} of the CVE list~\cite{cve} suggests that
they ``are number 2 for OS vendor advisories''.  A recent
survey~\cite{chen:kbugs} confirms the finding, where integer errors
account for more than one third of the reported Linux kernel
vulnerabilities from 2010 to early 2011 that can be misused to
corrupt the kernel and break its integrity.

Detecting integer errors at run time is difficult since they may
only manifest themselves with abnormal input, which are not seen
by typical users but can be exploited by adversaries.  Besides, a
module are not even loaded if some specific hardware is not available
or a particular configuration switch is not turned on, making it
harder to eliminate integer errors in testing environments.

[[[non-trivial to make the code right. patches may be incorrect.]]]
--- precise bit-level reasoning of bounds required.

This paper presents \sys, a static analysis tool that detects integer
errors at compile time.

\begin{figure}
\input{code/bridge}
\caption{An integer error~\cite[CVE-2006-5751]{cve} in the Ethernet
bridge subsystem of the Linux kernel, which may lead to buffer
overflows and allow local users to execute arbitrary code via a
large \texttt{maxnum} from userspace.}
\label{f:bridge}
\end{figure}
