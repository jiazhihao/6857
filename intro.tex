\section{Introduction}
\label{s:intro}

Integers are fundamental data types in systems code.  Unlike
infinitely ranged mathematical integers, they use a fixed number
of bits to represent integral values bounded by a predefined range.
An integer operation may produce a numeric value that does not fall
into the range, which could cause lost or misinterpreted data, referred
as \emph{integer errors} in this paper.  Integer errors may introduce
further logic problems and security vulnerabilities if the consequence
is unexpected.

\autoref{f:bridge} shows an example of integer errors in the Linux
kernel.  The size for allocating \cc{buf} is computed from the
multiplication of \cc{maxnum}, a variable controlled by userspace,
and \cc{sizeof(struct __fdb_entry)}, the constant 16.  Assuming
32-bit platform, both \cc{maxnum} and \cc{size} are 32-bit unsigned
integers, ranging from 0 to $2^{32} - 1$.
The developer's intention is to limit the values of 
\cc{maxnum} and \cc{size} to 256 and 4096, respectively.

However, if an adversary supplies a large \cc{maxnum}, say
\cc{0xf0000000}, the multiplication $\cc{maxnum} \times 16$ would
overflow the 32-bit unsigned integer range and result in \cc{size}
being set to 0.  Subsequently, the sanity check $\cc{size} > 4096$
will be bypassed, so that the values of \cc{size} and \cc{maxnum}
are not correctly limited.  In this case \cc{buf} is allocated as
a zero-length buffer; any further access into \cc{buf} is out of
bounds and may cause a kernel panic (i.e., denial-of-service).
Furthermore, the adversary may control the out-of-bounds writes
(i.e., buffer overflow) in a more elaborate way with carefully
crafted input, so as to execute arbitrary code and gain root
privilege~\cite[CVE-2006-5751]{cve}.  In practice, a similar integer
error was used to untether the iOS jailbreak~\cite{esser:ios}.

Integer errors enable a spectrum of attacks.  In addition to
denial-of-service, buffer overflow, and privilege escalation we
just mentioned, a problematic integer may lead to information
leakage, for example, if it is used to determine the number of data
to be copied from kernel to userspace, raising privacy concerns.
It may cause more subtle logic bugs if the value is used in decision
making, such as misleading the kernel to kill an innocent
process~\cite[CVE-2011-4097]{cve}.

Integer errors have emerged as a threat to systems security.  A
2007 MITRE study~\cite{christey:vuln} suggests that they are already
``number 2 for OS vendor advisories'', only after buffer overflows.
A recent survey~\cite{chen:kbugs} reviews the reported Linux kernel
vulnerabilities in the CVE list~\cite{cve} from 2010 to early 2011,
and confirms the finding that integer errors account for more than
one third of the vulnerabilities that can be misused to corrupt the
kernel.

\if 0
To avoid integer errors developers need, for example, to perform
sanity checks on untrusted inputs.  Even with that in mind, writing
integer-error-free code is often more error-prone than expected.
In \autoref{f:bridge} though the developers were aware that \cc{size}
could be too large, they failed to limit the value in a correct
way.  XXX will show XXX more subtle mistakes we have identified,
including XXX erroneous patches that the developers have committed
to the mainline Linux kernel.  One of the cases, a two-line check,
had been fixed three times before we submitted a correct patch.

Integer errors are difficult to catch at run time during testing.
They may only manifest themselves with abnormal input, which are
not seen in typical usages.  Besides, a buggy module that contains
integer errors may only be loaded with some specific hardware or
configuration, which is unlikely to be fully explored in development
and testing environment.  Decent compilers like GCC have provided
code generation options such as \cc{-ftrapv} to insert runtime
checks for catching common integer errors.  Since doing so hurts
performance, these options are usually turned off in product
environment.
\fi

\begin{figure}[t]
\centering
\begin{subfigure}{\linewidth}
	\input{code/bridge}
	\vspace{-1.2em}
	\caption{The buggy code.}
	\label{f:bridge:orig}
\end{subfigure}
\begin{subfigure}{\linewidth}
	\vspace{1em}
	\input{code/bridge-p}
	\vspace{-1.2em}
	\caption{The patch (\cc{maxnum} is numbered for clarification).}
	\label{f:bridge:patch}
	\vspace{0.8em}
\end{subfigure}
\caption{An integer error~\cite[CVE-2006-5751]{cve} in the Ethernet
bridge subsystem of the Linux kernel, which may lead to buffer
overflows and allow local users to execute arbitrary code via a
large \cc{maxnum} from userspace.}
\label{f:bridge}
\end{figure}

This paper presents \sys, a static analysis tool that scans C-language
source code for integer errors.  It aims to aid developers detecting
and fixing integer errors at compile time.  The main advantage is
that it provides better code coverage without requiring to set up
a testing environment, install hardware devices, nor prepare input
data.

The key challenge facing \sys is knowing what are actual integer
errors.  Conceptually, any integer operation that produces a result
different from the infinitely ranged mathematical counterpart flags
a potentential integer error~\cite{air}.  However, lossy truncations
and sign conversions are commonly seen in C code, most of which are
not damaging; overflow check idioms such as $x + y < x$ intentionally
use overflowed results to prevent integer errors.  \sys needs a
practical model to define integer errors, i.e., the precondition
under which an integer operation will go wrong.

A second challenge is to precisely reason about integer operations
on every code path.  Given the error precondition of an integer
operation, \sys needs to determine whether the control flow can
reach the operation while satisfying the precondition.  As for
\autoref{f:bridge}, \sys needs to conclude that the overflowed
product \cc{size} will bypass the check and reach the \cc{kmalloc}
call.

The final challenge is to apply \sys to large-scale systems code like
the Linux kernel.  The size of constraints may grow exponentially
with a large number of function calls and loops present.  Besides,
integer operations such as division~\cite{brummayer:perf} will slow
down the solver significantly.  Constraints generated unwisely will
make it impossible to finish the solving in a reasonably amount
of time even with a highly optimized constraint solver.

\sys addresses these challenges with a set of constraint generation
algorithms tailored for integer errors.  They effectively reduce
false errors and make the generated constraints to be solved
efficiently.  \sys also introduces practical criteria for ranking
integer errors by estimating their security impacts.

We have applied \sys to XXX.  XXX patches have been upstreamed..

The rest of this paper is organized as follows. \autoref{s:oview}
gives an overview of \sys.  \autoref{s:gen} presents how \sys
generates constraints...  We related \sys to previous work in
\autoref{s:relwk}, and conclude in \autoref{s:concl}.
