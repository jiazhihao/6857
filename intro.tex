\section{Introduction}
\label{s:intro}

Integer errors, including arithmetic overflow, division-by-zero,
oversized shift, lossy truncation, and sign misinterpretation, have
emerged as a threat to systems security.  A 2007 MITRE
study~\cite{christey:vuln} suggests that they are already ``number
2 for OS vendor advisories'', only after buffer overflows.  A recent
survey~\cite{chen:kbugs} reviews the reported Linux kernel
vulnerabilities in the Common Vulnerabilities and Exposures (CVE)
list~\cite{cve} from 2010 to early 2011, and confirms the finding
that integer errors account for more than one third of the
vulnerabilities that can be misused to corrupt the kernel and gain
root privilege.

\autoref{f:bridge} shows an example of integer errors (CVE-2006-5751)
in the Linux kernel.  The size for allocating \cc{buf} is computed
from the multiplication of \cc{maxnum}, a value controlled by user
space, and \cc{sizeof(struct __fdb_entry)}, the constant 16.  Assuming
32-bit platform, both \cc{maxnum} and \cc{size} are 32-bit unsigned
integers, ranging from 0 to $2^{32} - 1$.  The developer's intention
is to limit the values of \cc{maxnum} and \cc{size} to 256 and 4096,
respectively.

If an adversary supplies a large \cc{maxnum}, say
\cc{0xf0000000}, however, the multiplication $\cc{maxnum} \times 16$ would
overflow the 32-bit unsigned integer range and result in \cc{size}
being set to 0.  Subsequently, the sanity check $\cc{size} > 4096$
will be bypassed, so that the values of \cc{size} and \cc{maxnum}
are incorrectly limited.  In this case \cc{buf} is allocated as
a zero-length buffer; any further access into \cc{buf} is out of
bounds and may cause a kernel panic (i.e., denial-of-service).
Furthermore, the adversary may control the out-of-bounds writes
(i.e., buffer overflow) in a more elaborate way with carefully
crafted input, so as to execute arbitrary code and gain root
privilege.  A similar integer error was actually exploited to
untether the iOS jailbreak~\cite{esser:ios}.

Integer errors enable a spectrum of attacks.  In addition to
denial-of-service, buffer overflow, and privilege escalation we
just mentioned, a problematic integer error may also lead to information
leakage, for example, if it is used to determine the number of data
items to be copied from kernel to user space, raising privacy
concerns.  It may cause more subtle logic bugs if the value is used
in decision making, such as misleading the kernel to kill an innocent
process (CVE-2011-4097).

\begin{figure}[t]
\centering
\input{code/bridge}
\vspace{-1em}
\caption{An integer error (CVE-2006-5751) in the Ethernet
bridge subsystem of the Linux kernel, where a multiplication overflow
may lead to buffer overflows and allow local users to execute
arbitrary code via a large \cc{maxnum} from user space.
}
\label{f:bridge}
\end{figure}

This paper presents \sys, a compile-time tool that analyzes C-language
source code for integer errors.
%
The key challenge facing \sys is knowing what are actual integer
errors.
For example, some previous tools
rigidly classify any signed-to-unsigned integer conversion from a
possibly negative value as an error~\cite{brumley:rich, moy:z3prefix,
seacord:secure-c}; such sign conversions are so widely used in C
code that doing so would cause a flood of noisy false
errors~\cite[\subsectionautorefname~6.2]{moy:z3prefix}.
Developers even intentionally count on integer overflows
such as $x + y < x$ for the correctness of their programs~\cite{ioc},
which \sys should not consider as errors.
\sys needs an integer semantics that recognizes commonly used code
patterns while still effectively catches integer errors.
%Conceptually, any integer operation that may produce a
%result different from the infinitely ranged mathematical counterpart
%flags a potential integer error~\cite{air}.

A second challenge is to precisely reason about integer operations
on every code path.  Given the semantics of an integer operation,
\sys needs to determine whether the control flow can reach that
operation while simultaneously violating the semantics.  For
example, in \autoref{f:bridge} \sys should conclude that an overflowed
product \cc{size} will bypass the sanity check and reach the
\cc{kmalloc} call.

The final challenge is to apply \sys to large systems such as the
Linux kernel.  \sys needs to finish scanning the source code in a
reasonable amount of time.  \sys also should rank reported integer
errors and remove unlikely ones for human inspection if the bug
list is long.

\sys addresses these challenges with three ideas: a practical integer
semantics that defines integer errors, a precise analysis algorithm
that performs bit-level reasoning per function, and a set of ranking
criteria that estimate the security impacts of possible integer
errors.  \sys accept C source code as input, and inspects each
integer operation for possible integer errors.
%
It is implemented using the LLVM compiler framework~\cite{lattner:llvm}
and the Boolector constraint solver~\cite{boolector}.
%
To further reduce false errors, \sys asks users to provide a white
list of overflow checking idioms, as well as additional range
constraint annotations to filter out infeasible cases.

\sys identified \nrbugs integer errors in the Linux kernel,
the lighttpd web server, and OpenSSH, which were confirmed and fixed
by the developers.  It also reveals that even two previously known
CVE cases were fixed incorrectly.
%
We evaluate \sys's completeness by running it against 36 known
integer errors in the Linux kernel from the past three years; \sys
is able to detect 34 of them.

The rest of this paper is organized as follows. \autoref{s:sema}
defines the integer semantics that \sys uses.  \autoref{s:gen}
presents \sys's design for generating constraints.  \autoref{s:rank}
describes ranking heuristics.  \autoref{s:eval} evaluates \sys using
the Linux kernel source tree and known CVE cases.  \autoref{s:common}
summarizes common integer errors and \autoref{s:miti} discusses
future mitigation strategies.  \autoref{s:relwk} relates \sys to previous
work and \autoref{s:concl} concludes.
