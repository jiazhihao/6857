\section{Introduction}
\label{s:intro}

Integer errors, including arithmetic overflow, division-by-zero,
oversized shift, lossy truncation, and sign misinterpretation, have
emerged as a threat to systems security.  A 2007 MITRE
study~\cite{christey:vuln} suggests that they are already ``number
2 for OS vendor advisories'', only after buffer overflows.  A recent
survey~\cite{chen:kbugs} reviews the reported Linux kernel
vulnerabilities in the CVE list~\cite{cve} from 2010 to early 2011,
and confirms the finding that integer errors account for more than
one third of the vulnerabilities that can be misused to corrupt the
kernel and gain root privilege.

\if 0
Integers are fundamental data types in systems code.  Unlike
infinitely ranged mathematical integers, they use a fixed number
of bits to represent integral values bounded by a predefined range.
An integer operation may produce a numeric value that does not fall
into the range, which could cause lost or misinterpreted data, referred
as \emph{integer errors} in this paper.  Integer errors may introduce
further logic problems and security vulnerabilities if the consequence
is unexpected.
\fi

\autoref{f:bridge} shows an example of integer errors in the Linux
kernel.  The size for allocating \cc{buf} is computed from the
multiplication of \cc{maxnum}, a value controlled by user space,
and \cc{sizeof(struct __fdb_entry)}, the constant 16.  Assuming
32-bit platform, both \cc{maxnum} and \cc{size} are 32-bit unsigned
integers, ranging from 0 to $2^{32} - 1$.
The developer's intention is to limit the values of 
\cc{maxnum} and \cc{size} to 256 and 4096, respectively.

If an adversary supplies a large \cc{maxnum}, say
\cc{0xf0000000}, however, the multiplication $\cc{maxnum} \times 16$ would
overflow the 32-bit unsigned integer range and result in \cc{size}
being set to 0.  Subsequently, the sanity check $\cc{size} > 4096$
will be bypassed, so that the values of \cc{size} and \cc{maxnum}
are not correctly limited.  In this case \cc{buf} is allocated as
a zero-length buffer; any further access into \cc{buf} is out of
bounds and may cause a kernel panic (i.e., denial-of-service).
Furthermore, the adversary may control the out-of-bounds writes
(i.e., buffer overflow) in a more elaborate way with carefully
crafted input, so as to execute arbitrary code and gain root
privilege~\cite[CVE-2006-5751]{cve}.  A similar integer error was
actually exploited to untether the iOS jailbreak~\cite{esser:ios}.

Integer errors enable a spectrum of attacks.  In addition to
denial-of-service, buffer overflow, and privilege escalation we
just mentioned, a problematic integer error may lead to information
leakage, for example, if it is used to determine the number of data
items to be copied from kernel to user space, raising privacy
concerns.  It may cause more subtle logic bugs if the value is used
in decision making, such as misleading the kernel to kill an innocent
process~\cite[CVE-2011-4097]{cve}.


\if 0
To avoid integer errors developers need, for example, to perform
sanity checks on untrusted inputs.  Even with that in mind, writing
integer-error-free code is often more error-prone than expected.
In \autoref{f:bridge} though the developers were aware that \cc{size}
could be too large, they failed to limit the value in a correct
way.  XXX will show XXX more subtle mistakes we have identified,
including XXX erroneous patches that the developers have committed
to the mainline Linux kernel.  One of the cases, a two-line check,
had been fixed three times before we submitted a correct patch.

Integer errors are difficult to catch at run time during testing.
They may only manifest themselves with abnormal input, which are
not seen in typical usages.  Besides, a buggy module that contains
integer errors may only be loaded with some specific hardware or
configuration, which is unlikely to be fully explored in development
and testing environment.  Decent compilers like GCC have provided
code generation options such as \cc{-ftrapv} to insert runtime
checks for catching common integer errors.  Since doing so hurts
performance, these options are usually turned off in product
environment.
\fi

\begin{figure}[t]
\centering
\input{code/bridge}
\vspace{-1em}
\caption{An integer error~\cite[CVE-2006-5751]{cve} in the Ethernet
bridge subsystem of the Linux kernel, where a multiplication overflow
may lead to buffer overflows and allow local users to execute
arbitrary code via a large \cc{maxnum} from user space.}
\label{f:bridge}
\end{figure}

This paper presents \sys, a compile-time tool that scans C-language
source code for integer errors.
\if 0
It aims to aid developers detecting
and fixing integer errors at compile time.  Compared to run-time
checking, the main advantage of \sys is that it provides better
code coverage without requiring to set up a testing environment,
install hardware devices, nor prepare input data.
\fi
The key challenge facing \sys is knowing what are actual integer
errors.  Conceptually, any integer operation that may produce a
result different from the infinitely ranged mathematical counterpart
flags a potential integer error~\cite{air}.  However, truncations
and sign conversions are commonly seen in C code; overflow check
idioms such as $x + y < x$ intentionally use overflowed results to
prevent integer errors.  \sys needs an integer semantics that
recognizes commonly used code patterns while still effectively
catches integer errors.

A second challenge is to precisely reason about integer operations
on every code path.  Given the semantics of an integer operation,
\sys needs to determine whether the control flow can reach that
operation while simultaneously violating the semantics.  As for the
example in \autoref{f:bridge}, \sys should conclude that an overflowed
product \cc{size} will bypass the sanity check and reach the
\cc{kmalloc} call.

The final challenge is to apply \sys to large systems such as the
Linux kernel.  \sys needs to finish scanning the source code in a
reasonable amount of time.  \sys also should rank reported integer
errors and screen out unlikely ones for human inspection if the bug
list is long.

\sys addresses these challenges with three ideas: a practical integer
semantics that defines integer errors, a precise analysis algorithm
that performs bit-level reasoning per function, and a set of ranking
criteria that estimate the security impacts of possible integer
errors.  \sys accepts C source code as input, and inspects each
integer operation for possible integer errors.
%
\if 0
On a per-function basis \sys generates precise bit-level integer
constraints and consults a standard constraint
solver~\cite{boolector} to decide the satisfiability
of these constraints, i.e., whether the operation can become an
integer error. 
%\sys proposes a set of pragmatic constraint generation
%algorithms tailored for integer errors.  They are designed to
%effectively filter out false errors and make the generated constraints
%to be solved efficiently.
%
On a whole-program basis \sys infers and propagates coarse-grained
integer ranges across functions for better performance.
%
\sys introduces practical criteria for ranking integer
errors by estimating their security impacts on the control flow and
data integrity.
\fi
%
It is implemented in the LLVM compiler framework~\cite{lattner:llvm}
with the Boolector constraint solver~\cite{boolector}.

Applying \sys to XXX result in XXX patches that get upstream.

%The main contributions of this work are: a set of pragmatic constraint
%generation algorithms for integer errors, and XXX patches.

The rest of this paper is organized as follows. \autoref{s:sema}
defines the integer semantics.  \autoref{s:gen} presents how \sys generates
constraints...  We related \sys to previous work in \autoref{s:relwk},
and conclude in \autoref{s:concl}.
