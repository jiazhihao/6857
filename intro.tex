\section{Introduction}
\label{s:intro}

Integers are fundamental data types in systems code.  Unlike
infinitely ranged mathematical integers, they use a fixed number
of bits to represent integral values bounded by a predefined range.
An integer operation may produce a numeric value that does not fall
into the range, which could cause lost or misinterpreted data, referred
as \emph{integer errors} in this paper.  Integer errors may introduce
further logic problems and security vulnerabilities if the consequence
is unexpected.

\autoref{f:bridge} shows an example of integer errors in the Linux
kernel.  The size for allocating \cc{buf} is computed from the
multiplication of \cc{maxnum}, a variable controlled by userspace,
and \cc{sizeof(struct __fdb_entry)}, the constant 16.  Assuming
32-bit platform, both \cc{maxnum} and \cc{size} are 32-bit unsigned
integers, ranging from 0 to $2^{32} - 1$.
The developer's intention is to limit the values of 
\cc{maxnum} and \cc{size} to 256 and 4096, respectively.

If an adversary supplies a large \cc{maxnum}, say \cc{0xf0000000},
the multiplication $\cc{maxnum} \times 16$ would overflow the 32-bit
unsigned integer range and result in \cc{size} being set to 0.
Subsequently, the sanity check $\cc{size} > 4096$ will be bypassed,
so that the values of \cc{size} and \cc{maxnum} are not correctly
limited.  In this case \cc{buf} is allocated as a zero-length buffer;
any further access into \cc{buf} is out of bounds and may cause a
kernel panic (i.e., denial-of-service).  Furthermore, the adversary
may control the out-of-bounds writes (i.e., buffer overflow) in a
more elaborate way with carefully crafted input, so as to execute
arbitrary code and gain root privilege~\cite[CVE-2006-5751]{cve}.
In practice, a similar integer error was used to untether the iOS
jailbreak~\cite{esser:ios}.

Integer errors enable a spectrum of attacks.  In addition to
denial-of-service, buffer overflow, and privilege escalation we
just mentioned, a problematic integer may lead to information
leakage, for example, if it is used to determine the number of data
to be copied from kernel to userspace, raising privacy concerns.
It may cause more subtle logic bugs if the value is used in decision
making, such as misleading the kernel to kill an innocent
process~\cite[CVE-2011-4097]{cve}.

Integer errors have emerged as a threat to system security.  A 2007
study~\cite{christey:vuln} of the CVE list~\cite{cve} suggests that
they ``are number 2 for OS vendor advisories''.  A recent
survey~\cite{chen:kbugs} confirms the finding, where integer errors
account for more than one third of the reported Linux kernel
vulnerabilities from 2010 to early 2011 that can be misused to
corrupt the kernel and break its integrity.

To avoid integer errors developers need, for example, to perform
sanity checks on untrusted inputs.  Even with that in mind, writing
integer-error-free code is often more error-prone than expected.
In \autoref{f:bridge} though the developers were aware that \cc{size}
could be too large, they failed to limit the value in a correct
way.  XXX will show XXX more subtle mistakes we have identified,
including XXX erroneous patches that the developers have committed
to the mainline Linux kernel.  One of the cases, a two-line check,
had been fixed three times before we submitted a correct patch.

Integer errors are difficult to catch at run time during testing.
They may only manifest themselves with abnormal input, which are
not seen in typical usages.  Besides, a buggy module that contains
integer errors may only be loaded with some specific hardware or
configuration, which is unlikely to be fully explored in development
and testing environment.  Decent compilers like GCC have provided
code generation options such as \cc{-ftrapv} to insert runtime
checks for catching common integer errors.  Since doing so hurts
performance, these options are usually turned off in product
environment.

\begin{figure}
\input{code/bridge}
\caption{An integer error~\cite[CVE-2006-5751]{cve} in the Ethernet
bridge subsystem of the Linux kernel, which may lead to buffer
overflows and allow local users to execute arbitrary code via a
large \texttt{maxnum} from userspace.}
\label{f:bridge}
\end{figure}

This paper presents \sys, a static analysis tool that detects integer
errors at compile time.  It performs precise bit-level reasoning
of each integer operation, and extracts the constraint under which
the operation would lead to an error.  \sys then queries a constraint
solver~\cite{boolector} to determine whether the constraint can be
satisfied and warns against possible integer errors.

The key challenge facing \sys is to filter out false errors and
locate true bugs.  False errors could be caused by the inherent
imprecision of static analysis.  Commonly used code idioms may also
contain benign integer errors that will not cause any software
defects; \sys should recognize them and generate constraints
accordingly.

Another challenge is to apply \sys to large-scale systems code like
the Linux kernel.  The size of constraints may grow exponentially
with a large number of function calls and loops present.  Besides,
integer operations such as division~\cite{brummayer:perf} will slow
down the solver significantly.  Constraints generated unwisely will
make it impossible to finish the solving in a reasonably amount
of time even with a highly optimized constraint solver.

\sys addresses these challenges with a set of constraint generation
algorithms tailored for integer errors.  They effectively reduce
false errors and make the generated constraints to be solved
efficiently.  \sys also introduces practical criteria for ranking
integer errors by estimating their security impacts.

We have applied \sys to XXX.  XXX patches have been upstreamed..

The rest of this paper is organized as follows. \autoref{s:oview}
gives an overview of \sys.  \autoref{s:gen} presents how \sys
generates constraints...  We related \sys to previous work in
\autoref{s:relwk}, and conclude in \autoref{s:concl}.
