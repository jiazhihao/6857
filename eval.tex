\section{Evaluation}
\label{s:eval}

The evaluation answers the following questions:
\begin{CompactItemize}
\item
Is \sys effective in discovering new integer errors?
\item
How complete are \sys's reports?
\item
How many false errors are in \sys's reports?
\item
How long does it take \sys to analyze a large system such
as the Linux kernel?
\end{CompactItemize}

All the experiments were conducted on a 64-bit Ubuntu Linux machine
with an Intel Core i7-980 3.3~GHz CPU and 24~GB of memory.  The
processor has 6 cores, and each core has 2 hardware threads.

\subsection{New Bugs}
\label{s:eval:linux}

We periodically applied \sys to the latest Linux kernel
from November 2011 (v3.2) to April 2012 (v3.4-rc4),
and submitted patches according to \sys's reports.
The kernel developers confirmed and fixed \nrbugslinux integer errors.
%
We also applied \sys to two popular user-space applications, lighttpd
and OpenSSH; the developers fixed respectively \nrbugslighttpd and \nrbugsopenssh
integer errors reported by \sys.
%
The results show that \sys is effective in finding new integer
errors, and the developers are willing to fix them.  The rest
of this subsection explores the bugs found in Linux in more detail.

\autoref{f:data:linux}
summarizes the integer errors \sys discovered in Linux.
Each line represents a patch that fixes one or more integer errors; the
number is shown in the ``Error'' column if it is more than one.  We
organize the patches based on the source directories.  Most
columns are self-explanatory.  ``Description'' shows the attack
vector and what values are affected.  ``\# of prev. checks'' shows
the number of previous validations in the code that tried to address the 
same problem but did it incorrectly or insufficiently. 

%``Patch accepted?'' shows how the kernel
%developers respond to our patches:
%\begin{itemize}
%\item
%\ok means that they accepted the patch.
%The optional ``modified'' means that they modified our patch for inclusion;
%otherwise they applied our patch without modifications.
%\item
%fixed: the bug was already fixed in some repository other than the
%mainline when \sys discovered it, so we withdrew our patch.
%\end{itemize}

The kernel developers modified \nrpatchesmod patches we submitted
before adopting them; they applied the rest of our patches without
modifications.
%incorrectly modified three of the patches
%we proposed; they withdrew these modifications after discussion on the
%mailing list.
%
%We omit \nrpatchesnoresp patches that did not receive any further response.
We also discovered an additional \nrbugsbyothers integer errors that
were concurrently discovered by others; these errors are not included
in \autoref{f:data:linux}.

\begin{figure*}
\centering
\footnotesize
\input{data/linux}
\caption{Integer errors discovered by \sys in the Linux
kernel.  Each line is a patch that tries to fix one
or more bugs (the number is in the ``Error'' column if more than
one).  For each patch, we list the corresponding subsystem, the
error operation with the number of bugs, the affected architectures
(32-bit and/or 64-bit), the security impact, a
description of the attack vector and affected values, and
the number of previous sanity checks from the history of the 
Linux kernel repository that attempt to address the same problem
incorrectly or insufficiently. }
\label{f:data:linux}
\end{figure*}

\subsubsection{Distribution}

The integer errors \sys found span a wide range of kernel subsystems,
including the core kernel, device drivers, file systems, and network
protocols.
72 out of the 100 errors affects both 32-bit and 64-bit architectures,
and other 23 errors are specific to 32-bit architecure.
%The core kernel has fewer integer errors, since it does not
%interact with the outside as frequently as the rest of the kernel.

Multiplication appears to be the most error-prone operation; it is
often used for calculating allocation size, such as $n \times
\cc{sizeof}(...)$.  This use is vulnerable if $n$ can be controlled
by an adversary, causing the allocation size to wrap around to an
unanticipated smaller value.

Surprisingly,  a simple tautological expression that 
compares an unsigned integer with 0 ($<_u 0$, usually for error handling),
affected several subsystems.
The wl128x driver alone contains 36 such bugs, effectively
disabling most of its error handling paths.

\subsubsection{Impact}

Integer errors that allow out-of-bounds writes (i.e., buffer
overflow) would break the integrity of the kernel and potentially
enable privilege escalation attacks.  They can be exploited via network,
local access, or malformed filesystem on disk.  We see a large number of
such errors in \cc{ioctl}, an infamous error-prone interface.
%
There are also two interesting vulnerabilities in the sound subsystem;
an adversary can exploit them by plugging in a malicious USB audio
device that responds with bogus sampling rates, leading to kernel
hang, DoS, or buffer overflow.

Integer errors cause timing bugs in several network protocol
implementations.  For example, when a user space application provides
a large timeout argument, the internal timer can wrap around
to a smaller timeout value.

Most logic related integer errors are due to tautological comparisons.
These bugs would effectively disable error handling, or make the kernel
behave in unanticipated ways. 

\sys also found two logic bugs that were caused by programmer's
confusion. One example from \cc{net/can} is shown below.
\input{code/can}
The intent of the code is to test whether the error counter \cc{errc}
has reached certain level.  However, this
comparison will never be true because the left-hand side of the test,
which extracts 7 bits from \cc{errc}, is at most
$2^7 - 1 = 127$.  The fix is to check the right bit according to the
specification, using $\cc{errc}\ \&\ \cc{0x80}$.

Two integer errors (in xenbus and sctp) turned out
to be non-exploitable.  The kernel developers still applied our
patches for clarification and reliability improvement.

\subsubsection{Bad Fixes}
\label{s:eval:bad}

Using log of changes in the kernel repository,
the ``\# of prev. checks'' column in \autoref{f:data:linux} counts
the number of previous sanity checks that were incorrect or insufficient.
It shows that even though developers realized the need to validate 
those values, it is still non-trivial to write correct checks.
One of the cases, sctp's autoclose timer, was incorrectly fixed
three times before we submitted correct a patch.

%
It is worth noting that \sys found bugs in two previous patches that
intended to fix vulnerabilities reported in the CVE list. 
These patches received extensive review. We describe them below.

\paragraph{CVE-2009-4307 (ext4).}
Below is the fix that performs a sanity check
on \cc{s_log_groups_per_flex} to prevent a division-by-zero DoS attack
when its value (read from disk) is large
and the result of the shift becomes zero.
\input{code/ext4-bad}
The fix turns out to be incorrect. 
In the sanity check, the value of \cc{groups_per_flex}
comes from a shift with a possible oversized amount.
%This would lead to two potential
%issues.
%
%First,
For example, when \cc{s_log_groups_per_flex} is set to 36,
$1 \shl 36$ is essentially $1 \shl 4 = 16$, 
since on x86 the shifting instruction truncates the amount to 5~bits.
This will bypass the check, leaving the two values
\cc{s_log_groups_per_flex}~(36) and \cc{groups_per_flex}~(16)
inconsistent.

\if 0
Second, the C compiler may rewrite undefined code in unexpected
ways.  Consider the following equivalent sanity check (which was
in the originally proposed patch), assuming \cc{groups_per_flex}
is an unsigned integer.
\input{code/ext4-badeqv}
We compiled the code using both Clang~3.0 and GCC~4.6, with optimization
option \cc{-O2}.  Clang optimizes away the check
$\cc{groups_per_flex} == 0$, since it considers the case impossible,
following the C standard.  This would make the patched code as
vulnerable as the original.  GCC~4.6 keeps the check, but
there is no guarantee that future versions will do the same.
\fi

CVE-2012-2100 was assigned to this imperfect fix after we submitted
a new patch, which performs the check
$\cc{sbi->s_log_groups_per_flex} > 31$ before the shift.

\paragraph{CVE-2008-3526 (sctp).}
Below is the fix that performs a sanity check on \cc{key_len} to
avoid an integer overflow and possible heap overflow if
\cc{key_len} is large.
\input{code/sctp-bad}
This fix does not work.  Consider $\cc{key_len} =
\cc{0xffffffff}$ (i.e., \cc{UINT_MAX}).
The result of the left-hand side of the check is then \cc{0x80000000}.
Since \cc{key_len} is unsigned,  the left-hand side result
is also treated as unsigned (i.e., $2^{31}$), which bypasses the check.

After discussion with the kernel developers, we came to the conclusion
that \cc{key_len} could not become that large, so that CVE-2008-3526 is
not exploitable, and the fix is unnecessary. Our patch was applied to 
clarify the case.


\subsection{Completeness Validation}
\label{s:eval:complete}

To evaluate \sys's completeness, we collected 36 known integer errors in the
Linux kernel from the CVE list~\cite{cve} over the last three years (excluding
those found by \sys).  They provide a comprehensive coverage of the whole source
tree. 
%For each
%case, we run \sys against both the original and the patched code
%snippets.
%Ideally \sys should catch the bugs in the original code,
%and declare that the bug is fixed in the patched code.
%
As shown in \autoref{f:data:cve}, 
\sys is able to catch 34 out of the 36 integer errors (94\%).
This shows that \sys's report is fairly complete.

\begin{figure}
\centering
\footnotesize
\input{data/cve}
\caption{The result of applying \sys to integer errors in Linux
kernel from the CVE list.  For each case, we show whether \sys
catches the expected bugs in the original code, and whether \sys
determines that the bug is fixed in the patched code.}
\label{f:data:cve}
\end{figure}

\sys misses the following two cases.

\paragraph{CVE-2009-4307 (ext4).}
This bug is due to a possible division by zero that is caused by
an oversized left shift on PowerPC\@.  \sys is able to catch the
oversized shift, but not the division by zero, because in \sys's
semantics a left shift never produces zero, as discussed in
\autoref{s:sema:def}.

\paragraph{CVE-2010-3865 (rds).}
This bug is due to an addition overflow that happens in an accumulation
loop.  \sys cannot catch the bug since it unrolls the loop only
once.

\subsection{False Errors}

To evaluate how many false errors are in \sys's reports,
we first tested \sys on the patched code of the CVE cases
in \autoref{s:eval:complete},
expecting that ideally \sys would not report any errors.
The results are also shown in \autoref{f:data:cve}.
\sys reports no bugs in 31 of the 36 cases, times out in 1 case, and
reports errors in 4 cases.
%
One case, the patched code of CVE-2010-3873 (x25),
contains additional integer errors that are covered by CVE-2010-4164,
which \sys correctly identified;
Two cases contain fixes as we have shown in \autoref{s:eval:linux}.
One case is a false error in CVE-2011-4097 (oom), as detailed below.
\input{code/oom}
The code
computes a score proportional to process $p$'s memory consumption.
It sums up the numbers of different 
memory pages that $p$ takes, divides the result by the total number
of pages to get a ratio, and scales it by 1000.
When the whole system is running out of memory,
the kernel kills the process with the highest score.

The patch changes the type of \cc{points} from \cc{int} to \cc{long} because
\cc{points} could be large on 64-bit systems; multiplying it by
1000 could overflow and produce an incorrect score,
causing an innocent process to be killed.

There is an implicit rule that the sum of these numbers of pages
(e.g., from \cc{get_mm_rss}) is at most \cc{totalpages}, so the
additions never overflow.  \sys is unaware of the rule and
reports false errors for these additions.

%\fk{separate in two paragraph? one about the 12 hours and one about the
%effectiveness of range analysis etc. to reduce false errors} 

%, and 2,255 are related to memory moving %sizes.

For the whole Linux kernel, \sys reported 134,051 warnings in total.
After filtering for sensitive sinks, 1,024 are related to memory
allocation sizes, 646 of which are derived from untrusted inputs.
This shows that \sys's ranking strategy is effective in helping users
focus on high-risk warnings.

We inspected 97 warnings in detail.  It took us roughly 12 hours
to discover the first batch of 6 exploitable errors.  The other 91
warnings are either false errors or overflows that we did not know
how to exploit.  Most of the false errors are due to imprecise range
analysis or lack of domain-specific knowledge.

% first batch: ?, (aacraid), uvc, drm, vmwgfx, vt6656, comedi

\subsection{Performance}
\label{s:eval:perf}

To measure the running time of \sys, we ran \sys against the source
code of Linux kernel 3.4-rc1, with all kernel modules enabled. 
We set the timeout to 5 seconds for each query to the constraint solver.
\sys analyzed 8,896 files and made 420,743 queries, 992 of which timed out.
The predicate generation and constraint solving (excluding compilation)
took 62 minutes.  This shows that \sys can analyze a large
system in a reasonable amount of time.

\if 0
\fk{weren't we going to delete this?}
As discussed in \autoref{s:gen:opt}, \sys rewrites error checking
idioms for better performance.  We measured the solving time of three
equivalent forms: division, multiplication, and overflow detection
circuit, for both 32- and 64-bit integers, respectively.  The results
are shown in \autoref{f:udiv}.  Each test is repeated 1,000 times.
For a single unsigned division operation the best form can
achieve up to 2.3-2.5 times speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of three unsigned multiplication overflow
checking forms: division, $2n$-bit multiplication, and the specialized
overflow detection predicate, measured in milliseconds, for both
32- and 64-bit integers.}
\label{f:udiv}
\end{figure}

\fi
