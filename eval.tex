\section{Evaluation}
\label{s:eval}

The evaluation tries to answer the following questions.
\begin{itemize}
\item
Is \sys effective to discover integer errors in practice?
\item
How complete will \sys report integer errors?
\end{itemize}

All the experiments are conducted on a 64-bit machine equipped with
Intel 3.2~G HZ CPU and 24~G memory.

\subsection{Case Study: Linux}

We periodically run \sys against the source code of the mainline
Linux kernel and submit patches to the kernel developers.
\autoref{f:data:linux} summarizes our experience.  Each line
represents a patchset that fixes one or more integer errors; the
number is shown in the ``Error'' column if it is more than one.  We
oraganize the patchsets based on the source directories.  Most
columns are self-explanatory.  ``Description'' shows the attack
vector and what values are infected.  ``\# of prev. fixes'' shows
the number of previous commits that tried to fix the same error but
didn't do it correctly.  ``Patch accepted?'' shows how the kernel
developers respond to our patches, in one of the following cases.
\begin{itemize}
\item
\ok: the kernel developers accepted the patch upstream.  We
additionally specify the original repository that contains the
patch,  such as (xen), if the patch has not shown up in the mainline.
\item
modified: the kernel developers modified our patch for inclusion.
\item
acked: the kernel developers acknowledged the bug,
but we cannot find the patch showing up in any repository.
\item
fixed: we withdrew the patch because the bug discovered in the
mainline was already fixed in some other repository.
\end{itemize}
We omit XXX patches that do not get further responses.

\begin{figure*}
\centering
\footnotesize
\input{data/linux}
\caption{Integer errors discovered by \sys in the latest Linux
kernel source trees.  Each line is a patchset that tries to fix one
or more bugs (the number is in the ``Error'' column if more than
one).  For each patchset, we list the corresponding component, the
error operation with the number of bugs, the security impact, a
description of the attack vector and affected values, the number
of previous commits that did not to fix the same problem correctly,
and how the kernel developers respond to the patchset.}
\label{f:data:linux}
\end{figure*}

We can see that \sys has discovered integer errors in a wide range
of kernel subsystems, including the memory management, drivers,
file systems, and network protocols.


\paragraph{Bad fixes.}
It is worth noting that six integer errors were fixed incorrectly
at least once before; one was fixed twice and another was fixed
three times, still ending up with buggy code.  We will show two
examples below.

\paragraph{Attack vectors.}

Two of the integer errors reported by \sys turn out to be not
exploitable.

\paragraph{Performance.}
To measure the performance, we run \sys against the Linux kernel
3.2 source code, on 12 CPU cores in parallel.  We set the timeout
to 5 seconds for each constraint solving.   \sys analyzes 8637 files,
10 of which timeouts, and makes 411,851 solving queries.  The
analysis (excluding compilation) takes 22 minutes to finish.

\paragraph{User-space code.}
Currently \sys's annotations and ranking heuristics are tailored
for the Linux kernel.  We only run \sys against two popular user-space
applications.  The developers have promptly fixed 5 integer errors
reported by \sys: 1 for lighttpd and 4 for OpenSSH.

\subsection{Completeness}

We have collected XXX integer errors in the Linux kernel from the
CVE list~\cite{cve} in recent three years as a benchmark to evaluate
\sys's completeness.  For each case, we run \sys against both the
original and the patched code snippets.  Ideally \sys should catch
the bugs in the orignal code, while declare that the bug is fixed
in the patched code.

\begin{figure*}
\centering
\footnotesize
\input{data/cve}
\caption{The result of applying \sys to integer errors in Linux
kernel from the CVE list.  Each test case consists of two parts:
the original and the patched code snippets.  We list the corresponding
component, the error operations, whether \sys catches the expected
bugs in the original code, and does not report the bug in the patched
code.}
\end{figure*}

\subsubsection{False Negatives}

\sys does not catch two integer errors, both of which have been
discussed in \autoref{s:gen:limit}.  We detail them below.

\xw{show code?}

\paragraph{CVE-2009-4307.}
\sys is able to detect the oversized shift, but does not catch the
division by zero, which could happen on PowerPC but not x86, since
\sys's default semantics does not model the PowerPC architecture.

\paragraph{CVE-2010-3865.}
The addition overflow happens in a loop, which is an accumulation.
\sys cannot catch the bug since it unrolls the loop only once.

\subsubsection{False Positives and New Bugs}



\subsection{Common Pitfalls}

miss sanity checks.

char$\to$int: 
CA-1996-22,
Apache,
lighttpd new bug

bad overflow checks: $x \times y < x$, 
\autoref{f:bridge}.

compilers and arch:
signed overflow (IntegerLib, etc.),
oversized shift (Google's Native Client sandboxing),
ABI on 64-bit S/390, PowerPC, SPARC, and MIPS
and 32-bit system call parameters~\cite[CVE-2009-0029]{cve}

pivot in binary search.

index checks:
miss (i < 0) or should declare i as unsigned

return values: (ret < 0)
should declare ret as signed.

\subsection{Microbenchmark}
\label{s:eval:micro}

\autoref{f:udiv} shows a microbenchmark that measures the solving
time of the three checking forms of 32- and 64-bit integers,
respectively.  Each test is repeated 1000 times.  For a single
unsigned division operation this optimization can achieve up to
2.5$\times$ speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of $\uintmax(n) /_u x > y$ and two variant
forms: $2n$-bit multiplication and the multiplication overflow
detection circuit, measured in milliseconds, for both 32- and 64-bit
integers.}
\label{f:udiv}
\end{figure}

\subsection{Patching}

What do patches look like?

simple sanity check.
- return -EINVAL or silently limit the value (e.g., timeout).

interface change (e.g., CVE-2009-2909)
sometimes infeasible if the interface is exposed to userspace.

misread specification (CAN bits).


