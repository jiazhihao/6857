\section{Evaluation}
\label{s:eval}

The evaluation tries to answer the following questions.
\begin{itemize}
\item
Is \sys effective in discovering new integer errors in practice?
\item
How complete are \sys's reports?
\item
How many false errors are in \sys's reports?
\item
How long does it take \sys to analyze a large system such
as the Linux kernel?
\end{itemize}

All the experiments were conducted on a 64-bit Ubuntu Linux machine
with an Intel Core i7-980 3.3~GHz CPU and 24~GB of memory.  The
processor has 6 cores, and each core has 2 hardware threads.

\subsection{New Bugs}
\label{s:eval:linux}

We periodically applied \sys to the latest Linux kernel
from November 2011 (v3.2) to April 2012 (v3.4-rc4),
and submitted patches according to \sys's reports.
The kernel developers confirmed and fixed \nrbugslinux integer errors.
%
We also applied \sys to two popular user-space applications, lighttpd
and OpenSSH; the developers fixed \nrbugslighttpd and \nrbugsopenssh
integer errors reported by \sys, respectively.
%
The results show that \sys is effective in finding new integer
errors, and the developers are willing to fix them.

We use the Linux kernel for a case study.  \autoref{f:data:linux}
summarizes integer errors \sys discovered in its source code.
Each line represents a patch that fixes one or more integer errors; the
number is shown in the ``Error'' column if it is more than one.  We
organize the patches based on the source directories.  Most
columns are self-explanatory.  ``Description'' shows the attack
vector and what values are infected.  ``\# of prev. fixes'' shows
the number of previous commits that tried to fix the same error but
did it incorrectly. 
%``Patch accepted?'' shows how the kernel
%developers respond to our patches:
%\begin{itemize}
%\item
%\ok means that they accepted the patch.
%The optional ``modified'' means that they modified our patch for inclusion;
%otherwise they applied our patch without modifications.
%\item
%fixed: the bug was already fixed in some repository other than the
%mainline when \sys discovered it, so we withdrew our patch.
%\end{itemize}

The kernel developers modified \nrpatchesmod patches we submitted
for inclusion; they applied the rest of our patches without
modifications.
%incorrectly modified three of the patches
%we proposed; they withdrew these modifications after discussion on the
%mailing list.
%
%We omit \nrpatchesnoresp patches that did not receive any further response.
We also discovered an additional \nrbugsbyothers integer errors that
were concurrently discovered by others; these errors are not included
in \autoref{f:data:linux}.

\begin{figure*}
\centering
\footnotesize
\input{data/linux}
\caption{Integer errors discovered by \sys in the latest Linux
kernel source trees.  Each line is a patch that tries to fix one
or more bugs (the number is in the ``Error'' column if more than
one).  For each patch, we list the corresponding subsystem, the
error operation with the number of bugs, the security impact, a
description of the attack vector and affected values, and the number
of previous commits that fixed the same problem incorrectly.}
\label{f:data:linux}
\end{figure*}

\subsubsection{Distribution}

The integer errors \sys found span a wide range of kernel subsystems,
including the core kernel, drivers, file systems, and network protocols.
The core kernel has fewer integer errors, since it does not
interact with the outside as frequently as the rest of the kernel.

Multiplication appears to be the most error-prone operation; it is
often used for calculating allocation size, such as $\cc{count}
\times \cc{sizeof}(...)$.  This is error-prone if \cc{count} can
be controlled by an adversary.

Surprisingly,  a simple tautological comparison $<_u 0$,
comparing an unsigned integer with 0 (usually for error handling),
affected several subsystems.
One driver (wl128x) contains 36 such bugs alone, effectively
disabling most of its error handling paths.

\subsubsection{Impact}

Integer errors that allow out-of-bounds writes (i.e., buffer
overflow) would break the integrity of the kernel and potentially
allow privilege escalation.  They can be exploited via local access,
disk (malformed filesystem), and network.  We see a large number of
errors in \cc{ioctl}, since it is error-prone and biased by \sys's
ranking heuristics.
%
There is also an interesting vulnerability in the sound subsystem;
an adversary can exploit it by plugging in a malicious USB audio
device that responds with bogus sampling rates, leading to kernel
hang, DoS, and overflow a buffer.

Integer errors cause timing bugs in several network protocol
implementations.  For example, a user-space application can try to
set a large timeout value, but the value could overflow and end up
with a small timeout.

Error-handling related integer errors would make the kernel behave in
unanticipated ways, though they are hard to exploit by an adversary.
Most of these bugs are simple tautological comparisons.

\sys also found two logic bugs that were caused by programmer
confusion rather than integer conversions.
Below is one example in CAN.
\begin{align*}
((\cc{errc}\ \&\ \cc{0x7f}) \shr 8) > 127.
\end{align*}
The intent of the code is to test whether the error counter \cc{errc}
has reached certain level.  However, this
comparison will never be true because the left-hand side of the test,
which extracts 7 bits, is at most
$2^7 - 1 = 127$.  The fix is to read the right bit according to the specification,
via $\cc{errc}\ \&\ \cc{0x80}$.

Two integer errors (in xenbus and sctp) turned out
to be non-exploitable.  The kernel developers still applied our
patches for clarification and reliability improvement.

\subsubsection{Bad Fixes}
\label{s:eval:bad}

\sys discovered 7 integer errors that were previously known but
fixed incorrectly.
The ``\# of prev. fixes'' column in \autoref{f:data:linux} counts
the incorrect patches that were committed into the mainline repository.
%those only proposed on the mailing list are not included.
Some integer errors were fixed incorrectly more than once before
we submitted a correct patch.

%
It is interesting that two bad patches were committed to fix
vulnerabilities reported on the CVE list, which received extensive
review.  We describe them below.

\paragraph{CVE-2008-3526 (sctp).}
Below is the fix that performs a sanity check on \cc{key_len} to
avoid an integer overflow and possible heap overflow if
\cc{key_len} is large.
\input{code/sctp-bad}
This sanity check in fact does not work.  Consider $\cc{key_len} =
\cc{0xffffffff}$ (i.e., \cc{UINT_MAX}).
The result of the left-hand side of the check is then \cc{0x80000000}.
Since \cc{key_len} is unsigned,  the left-hand side result
is also treated as unsigned, $2^{31}$, which bypasses the check.

After discussion with the kernel developers, we came to the conclusion
that \cc{key_len} could not become that large with input from either
user space or network by an adversary.  CVE-2008-3526 is not
exploitable, and the previous commit is unnecessary.  Our patch was
applied to clarify the case.

\paragraph{CVE-2009-4307 (ext4).}
Below is the fix that performs a sanity check
on the \cc{s_log_groups_per_flex} value, which is read from disk,
to prevent a division-by-zero DoS attack when the value is large
and the result of the shift becomes zero.
\input{code/ext4-bad}
In the sanity check, the value of \cc{groups_per_flex} comes from
a shift with a possible oversized amount.
%This would lead to two potential
%issues.
%
%First,
For example, on x86
when \cc{s_log_groups_per_flex} is set to a corrupted value like
36, $\cc{groups_per_flex} = 1 \shl 36$ is essentially $1 \shl 4 =
16$, since the shifting instruction truncates the amount to 5~bits.
This will bypass the check, leaving the two values
\cc{s_log_groups_per_flex}~(36) and \cc{groups_per_flex}~(16)
inconsistent.

\if 0
Second, the C compiler may rewrite undefined code in unexpected
ways.  Consider the following equivalent sanity check (which was
in the originally proposed patch), assuming \cc{groups_per_flex}
is an unsigned integer.
\input{code/ext4-badeqv}
We compiled the code using both Clang~3.0 and GCC~4.6, with optimization
option \cc{-O2}.  Clang optimizes away the check
$\cc{groups_per_flex} == 0$, since it considers the case impossible,
following the C standard.  This would make the patched code as
vulnerable as the original.  GCC~4.6 keeps the check, but
there is no guarantee that future versions will do the same.
\fi

CVE-2012-2100 was assigned to this imperfect fix after we submitted
a patch, which performs the check
$\cc{sbi->s_log_groups_per_flex} > 31$ before the shift.

\subsection{Completeness Validation}
\label{s:eval:complete}

We collected 36 known integer errors in the Linux kernel from the
CVE list~\cite{cve} over the last three years (excluding those found
by \sys for fairness) as a benchmark to evaluate
\sys's completeness, as shown in \autoref{f:data:cve}.  They provide
a comprehensive coverage of the whole source tree.
%For each
%case, we run \sys against both the original and the patched code
%snippets.
%Ideally \sys should catch the bugs in the original code,
%and declare that the bug is fixed in the patched code.
%
\sys is able to find 34 out of the 36 integer errors (94\%).
This shows that \sys's report is fairly complete.

\begin{figure*}
\centering
\footnotesize
\input{data/cve}
\caption{The result of applying \sys to integer errors in Linux
kernel from the CVE list.  We list the corresponding
subsystem, the error operations, whether \sys catches the expected
bugs in the original code, and whether \sys determines that the bug
is fixed in the patched code.}
\label{f:data:cve}
\end{figure*}

\sys misses the following two cases.

\paragraph{CVE-2009-4307 (ext4).}
This bug is due to a possible division by zero that is caused by
an oversized left shift on PowerPC\@.  \sys is able to catch the
oversized shift, but not the division by zero, because in \sys's
semantics a left shift never produces zero, as discussed in
\autoref{s:sema:def}.
\xw{how about removing this one?  it depends on how we revise
\autoref{s:sema:def} though.}

\paragraph{CVE-2010-3865 (rds).}
This bug is due to an addition overflow that happens in an accumulation
loop.  \sys cannot catch the bug since it unrolls the loop only
once.

\subsection{False Errors}

To evaluate how many false errors are in \sys's reports,
we first tested \sys on the patched code of these CVE cases
in \autoref{s:eval:complete},
and expected that ideally \sys would not report any errors.
The result is also shown in \autoref{f:data:cve}.
\sys declares no bug in 29 of the 36 cases, times out in 1 case, and
reports errors in 6 cases.
%
In these 6 cases,
the patched code of CVE-2010-3873 (x25)
contains additional integer errors that are covered by CVE-2010-4164,
which \sys correctly identified;
four cases contain either new errors or bad fixes,
as we have shown in \autoref{s:eval:linux}.
There is one false error in CVE-2011-4097 (oom), as detailed below.

\input{code/oom}
The code snippet
computes a score proportional to process $p$'s memory consumption.
It sums up different numbers of
memory pages $p$ takes, divide the result by the total number
of pages to get a ratio, and scale it by 1000.
When the whole system is running out of memory,
the kernel kills the process with the highest score
to free more memory.

The patch changes the type of \cc{points} from \cc{int} to \cc{long} because
\cc{points} could be large on 64-bit systems; multiplying it by
1000 could overflow and produce an incorrect score,
causing an innocent process being killed.

There is an implicit rule that the sum of these numbers of pages
(e.g., from \cc{get_mm_rss}) is at most \cc{totalpages}, so the
additions never overflow.  \sys does not understand the rule and
reports false errors on these additions.

\nz{replace the next paragraph with Haogang's more detailed
  analysis, starting with 400k+ total reports, and going down
  to ~700 errors with alloc sinks, etc.}

%The false error rate, recompensed by the raking heuristic described in Section
%\ref{s:rank}, is practical in analyzing large scale systems. In our experience
%on the whole Linux kernel
When applying \sys to the whole Linux kernel,
it warned 3350 integer errors used for calculating
memory allocation size.  We inspected 97 of them,
where values came from untrusted sources. It took us roughly 12
hours to discover the first batch of 6 exploitable bugs.
The other 91 warnings are either harmless overflows or false warnings.
Most of the false warnings are due to either imprecise range analysis
or lack of domain-specific knowledge.

% first batch: ?, (aacraid), uvc, drm, vmwgfx, vt6656, comedi

\subsection{Performance}
\label{s:eval:perf}

To measure the running time of \sys, we ran \sys against the source
code for Linux kernel 3.2.  We set the timeout
to 5 seconds for each constraint solving query.   \sys analyzed
8637 files, 10 of which timed out, and made 411,851 solving queries.
The predicate generation and constraint solving (excluding compilation)
cost 22 minutes.  This shows that \sys can finish analyzing a large
system within a reasonable amount of time.
\nz{report number of individual query timeouts, in addition to the
  number of files that had 1 or more timeouts.}

As discussed in \autoref{s:gen:opt}, \sys rewrites error checking
idioms for better performance.  We measured the solving time of three
equivalent forms: division, multiplication, and overflow detection
circuit, for both 32- and 64-integers, respectively.  The result
is shown in \autoref{f:udiv}.  Each test is repeated 1000 times.
For a single unsigned division operation this optimization can
achieve up to 2.5$\times$ speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of three unsigned multiplication overflow
checking forms: division, $2n$-bit multiplication, and the specialized
overflow detection predicate, measured in milliseconds, for both
32- and 64-bit integers.}
\label{f:udiv}
\end{figure}
