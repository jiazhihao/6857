\section{Evaluation}
\label{s:eval}

The evaluation tries to answer the following questions.
\begin{CompactItemize}
\item
Is \sys effective in discovering new integer errors?
\item
How complete are \sys's reports?
\item
How many false errors are in \sys's reports?
\item
How long does it take \sys to analyze a large system such
as the Linux kernel?
\end{CompactItemize}

All the experiments were conducted on a 64-bit Ubuntu Linux machine
with an Intel Core i7-980 3.3~GHz CPU and 24~GB of memory.  The
processor has 6 cores, and each core has 2 hardware threads.

\subsection{New Bugs}
\label{s:eval:linux}

We periodically applied \sys to the latest Linux kernel
from November 2011 (v3.2) to April 2012 (v3.4-rc4),
and submitted patches according to \sys's reports.
The kernel developers confirmed and fixed \nrbugslinux integer errors.
%
We also applied \sys to two popular user-space applications, lighttpd
and OpenSSH; the developers fixed \nrbugslighttpd and \nrbugsopenssh
integer errors reported by \sys, respectively.
%
The results show that \sys is effective in finding new integer
errors, and the developers are willing to fix them.

We use the Linux kernel for a case study.  \autoref{f:data:linux}
summarizes integer errors \sys discovered in its source code.
Each line represents a patch that fixes one or more integer errors; the
number is shown in the ``Error'' column if it is more than one.  We
organize the patches based on the source directories.  Most
columns are self-explanatory.  ``Description'' shows the attack
vector and what values are infected.  ``\# of prev. checks'' shows
the number of previous validations in the code that tried to address the 
same problem but did it incorrectly or insufficiently. 

%``Patch accepted?'' shows how the kernel
%developers respond to our patches:
%\begin{itemize}
%\item
%\ok means that they accepted the patch.
%The optional ``modified'' means that they modified our patch for inclusion;
%otherwise they applied our patch without modifications.
%\item
%fixed: the bug was already fixed in some repository other than the
%mainline when \sys discovered it, so we withdrew our patch.
%\end{itemize}

The kernel developers modified \nrpatchesmod patches we submitted
for inclusion; they applied the rest of our patches without
modifications.
%incorrectly modified three of the patches
%we proposed; they withdrew these modifications after discussion on the
%mailing list.
%
%We omit \nrpatchesnoresp patches that did not receive any further response.
We also discovered an additional \nrbugsbyothers integer errors that
were concurrently discovered by others; these errors are not included
in \autoref{f:data:linux}.

\begin{figure*}
\centering
\footnotesize
\input{data/linux}
\caption{Integer errors discovered by \sys in the latest Linux
kernel source trees.  Each line is a patch that tries to fix one
or more bugs (the number is in the ``Error'' column if more than
one).  For each patch, we list the corresponding subsystem, the
error operation with the number of bugs, the affected architectures
(32-bit and/or 64-bit), the security impact, a
description of the attack vector and affected values, and the number
of incorrect or insufficient checks that kernel developers wrote
previously in an attempt to address the same problem.}
\label{f:data:linux}
\end{figure*}

\subsubsection{Distribution}

The integer errors \sys found span a wide range of kernel subsystems,
including the core kernel, drivers, file systems, and network protocols.
The core kernel has fewer integer errors, since it does not
interact with the outside as frequently as the rest of the kernel.

Multiplication appears to be the most error-prone operation; it is
often used for calculating allocation size, such as $n \times
\cc{sizeof}(...)$.  This is vulnerable if $n$ can be controlled
by an adversary, causing the allocation size to wrap around to an
unanticipated smaller value.

Surprisingly,  a simple tautological comparison $<_u 0$,
comparing an unsigned integer with 0 (usually for error handling),
affected several subsystems.
One driver (wl128x) contains 36 such bugs alone, effectively
disabling most of its error handling paths.

\subsubsection{Impact}

Integer errors that allow out-of-bounds writes (i.e., buffer
overflow) would break the integrity of the kernel and potentially
allow privilege escalation.  They can be exploited via local access,
disk (malformed filesystem), and network.  We see a large number of
errors in \cc{ioctl}, an infamous error-prone interface.
%
There are also two interesting vulnerabilities in the sound subsystem;
an adversary can exploit them by plugging in a malicious USB audio
device that responds with bogus sampling rates, leading to kernel
hang, DoS, or buffer overflow.

Integer errors cause timing bugs in several network protocol
implementations.  For example, when a user-space application sets
a large timeout value, the value could wrap around to
with a small timeout.

Error-handling related integer errors would make the kernel behave in
unanticipated ways, though they are hard to exploit by an adversary.
Most of these bugs are simple tautological comparisons.

\sys also found two logic bugs that were caused by programmer
confusion rather than integer conversions.
Below is one example in CAN\@.
\begin{align*}
((\cc{errc}\ \&\ \cc{0x7f}) \shr 8) > 127.
\end{align*}
The intent of the code is to test whether the error counter \cc{errc}
has reached certain level.  However, this
comparison will never be true because the left-hand side of the test,
which extracts 7 bits, is at most
$2^7 - 1 = 127$.  The fix is to read the right bit according to the specification,
via $\cc{errc}\ \&\ \cc{0x80}$.

Two integer errors (in xenbus and sctp) turned out
to be non-exploitable.  The kernel developers still applied our
patches for clarification and reliability improvement.

\subsubsection{Bad Fixes}
\label{s:eval:bad}

The ``\# of prev. checks'' column in \autoref{f:data:linux} counts
the number of sanity checks that were incorrect or insufficient
from the history of the Linux kernel repository.
It shows that even though developers were aware of the fact that
those values needed sanity checking, it is still non-trivial
to write correct checks.
One of the cases, sctp's autoclose timer, was incorrectly fixed
three times before we submitted a patch.

%
It is interesting that two bad patches were committed to fix
vulnerabilities reported on the CVE list, which received extensive
review.  We describe them below.

\paragraph{CVE-2008-3526 (sctp).}
Below is the fix that performs a sanity check on \cc{key_len} to
avoid an integer overflow and possible heap overflow if
\cc{key_len} is large.
\input{code/sctp-bad}
This sanity check in fact does not work.  Consider $\cc{key_len} =
\cc{0xffffffff}$ (i.e., \cc{UINT_MAX}).
The result of the left-hand side of the check is then \cc{0x80000000}.
Since \cc{key_len} is unsigned,  the left-hand side result
is also treated as unsigned, $2^{31}$, which bypasses the check.

After discussion with the kernel developers, we came to the conclusion
that \cc{key_len} could not become that large with input from either
user space or network by an adversary.  CVE-2008-3526 is not
exploitable, and the previous commit is unnecessary.  Our patch was
applied to clarify the case.

\paragraph{CVE-2009-4307 (ext4).}
Below is the fix that performs a sanity check
on the \cc{s_log_groups_per_flex} value, which is read from disk,
to prevent a division-by-zero DoS attack when the value is large
and the result of the shift becomes zero.
\input{code/ext4-bad}
In the sanity check, the value of \cc{groups_per_flex} comes from
a shift with a possible oversized amount.
%This would lead to two potential
%issues.
%
%First,
For example, on x86
when \cc{s_log_groups_per_flex} is set to a corrupted value like
36, $\cc{groups_per_flex} = 1 \shl 36$ is essentially $1 \shl 4 =
16$, since the shifting instruction truncates the amount to 5~bits.
This will bypass the check, leaving the two values
\cc{s_log_groups_per_flex}~(36) and \cc{groups_per_flex}~(16)
inconsistent.

\if 0
Second, the C compiler may rewrite undefined code in unexpected
ways.  Consider the following equivalent sanity check (which was
in the originally proposed patch), assuming \cc{groups_per_flex}
is an unsigned integer.
\input{code/ext4-badeqv}
We compiled the code using both Clang~3.0 and GCC~4.6, with optimization
option \cc{-O2}.  Clang optimizes away the check
$\cc{groups_per_flex} == 0$, since it considers the case impossible,
following the C standard.  This would make the patched code as
vulnerable as the original.  GCC~4.6 keeps the check, but
there is no guarantee that future versions will do the same.
\fi

CVE-2012-2100 was assigned to this imperfect fix after we submitted
a patch, which performs the check
$\cc{sbi->s_log_groups_per_flex} > 31$ before the shift.

\subsection{Completeness Validation}
\label{s:eval:complete}

To evaluate \sys's completeness, We collected 36 known integer errors in the
Linux kernel from the CVE list~\cite{cve} over the last three years (excluding
those found by \sys).  They provide a comprehensive coverage of the whole source
tree. 
%For each
%case, we run \sys against both the original and the patched code
%snippets.
%Ideally \sys should catch the bugs in the original code,
%and declare that the bug is fixed in the patched code.
%
As shown in \autoref{f:data:cve}, 
\sys is able to find 34 out of the 36 integer errors (94\%).
This shows that \sys's report is fairly complete.

\begin{figure}
\centering
\footnotesize
\input{data/cve}
\caption{The result of applying \sys to integer errors in Linux
kernel from the CVE list.  For each case, we show whether \sys
catches the expected bugs in the original code, and whether \sys
determines that the bug is fixed in the patched code.}
\label{f:data:cve}
\end{figure}

\sys misses the following two cases.

\paragraph{CVE-2009-4307 (ext4).}
This bug is due to a possible division by zero that is caused by
an oversized left shift on PowerPC\@.  \sys is able to catch the
oversized shift, but not the division by zero, because in \sys's
semantics a left shift never produces zero, as discussed in
\autoref{s:sema:def}.

\paragraph{CVE-2010-3865 (rds).}
This bug is due to an addition overflow that happens in an accumulation
loop.  \sys cannot catch the bug since it unrolls the loop only
once.

\subsection{False Errors}

To evaluate how many false errors are in \sys's reports,
we first tested \sys on the patched code of these CVE cases
in \autoref{s:eval:complete},
and expected that ideally \sys would not report any errors.
The results are also shown in \autoref{f:data:cve}.
\sys reports no bugs in 29 of the 36 cases, times out in 1 case, and
reports errors in 6 cases.
%
In these 6 cases,
the patched code of CVE-2010-3873 (x25)
contains additional integer errors that are covered by CVE-2010-4164,
which \sys correctly identified;
four cases contain either new errors or bad fixes,
as we have shown in \autoref{s:eval:linux}.
There is one false error in CVE-2011-4097 (oom), as detailed below.

\input{code/oom}
The code
computes a score proportional to process $p$'s memory consumption.
It sums up different numbers of
memory pages $p$ takes, divide the result by the total number
of pages to get a ratio, and scale it by 1000.
When the whole system is running out of memory,
the kernel kills the process with the highest score
to free more memory.

The patch changes the type of \cc{points} from \cc{int} to \cc{long} because
\cc{points} could be large on 64-bit systems; multiplying it by
1000 could overflow and produce an incorrect score,
causing an innocent process to be killed.

There is an implicit rule that the sum of these numbers of pages
(e.g., from \cc{get_mm_rss}) is at most \cc{totalpages}, so the
additions never overflow.  \sys does not understand the rule and
reports false errors for these additions.

When applying \sys to the whole Linux kernel, it reported 134,051 possible
integer errors in total. After filtering for sensitive sinks, 1,024 of them are
related to memory allocation sizes, and 2,255 are related to memory moving
sizes.  Out of the 1,024 reported allocation size errors, 646 are derived from
untrusted inputs.  We scanned through them and inspected 97 reports in detail.
It took us roughly 12 hours to discover 6 exploitable errors.
The other 91 warnings are either harmless overflows or false warnings.  Most of
the false warnings are due to imprecise range analysis or lack of
domain-specific knowledge.

% first batch: ?, (aacraid), uvc, drm, vmwgfx, vt6656, comedi

\subsection{Performance}
\label{s:eval:perf}

To measure the running time of \sys, we ran \sys against the source
code of Linux kernel 3.4-rc1.  We set the timeout
to 5 seconds for each constraint solving query.   \sys analyzed
8,896 files and made 420,743 solving queries, 992 of which timeouts.
The predicate generation and constraint solving (excluding compilation)
took 40 minutes.  This shows that \sys can analyze a large
system in a reasonable amount of time.

As discussed in \autoref{s:gen:opt}, \sys rewrites error checking
idioms for better performance.  We measured the solving time of three
equivalent forms: division, multiplication, and overflow detection
circuit, for both 32- and 64-bit integers, respectively.  The results
are shown in \autoref{f:udiv}.  Each test is repeated 1,000 times.
For a single unsigned division operation the best form can
achieve up to 2.5$\times$ speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of three unsigned multiplication overflow
checking forms: division, $2n$-bit multiplication, and the specialized
overflow detection predicate, measured in milliseconds, for both
32- and 64-bit integers.}
\label{f:udiv}
\end{figure}
