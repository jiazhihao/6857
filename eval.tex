\section{Evaluation}
\label{s:eval}

The evaluation tries to answer the following questions.
\begin{itemize}
\item
Is \sys effective to catch integer errors in buggy code?
\item
Will \sys declare that patched code does not contain no integer errors?
\item
Can \sys find integer errors in real-world systems?
\end{itemize}

\subsection{Validation}

We have collected XXX integer errors (both original and patched
code snippets) in the Linux kernel from the CVE list~\cite{cve} in
recent three years and use them as the benchmark to validate \sys.

\newcommand{\ok}{\textcolor{JungleGreen}{\checkmark}\xspace}
\newcommand{\checked}{$\boxtimes$}
\begin{figure*}
\centering
\footnotesize
\input{data/cve}
\caption{The result of applying \sys to integer errors in Linux
kernel from the CVE list.}
\end{figure*}

\subsubsection{False Negatives}

\sys does not catch two integer errors, both of which have been
discussed in \autoref{s:gen:limit}.  We detail them below.

\xw{show code?}

\paragraph{CVE-2009-4307.}
\sys is able to detect the oversized shift, but does not catch the
division by zero, which could happen on PowerPC but not x86, since
\sys's default semantics does not model the PowerPC architecture.

\paragraph{CVE-2010-3865.}
The addition overflow happens in a loop, which is an accumulation.
\sys cannot catch the bug since it unrolls the loop only once.

\subsubsection{False Positives and New Bugs}


\subsection{Case Study}

We periodically run \sys against the source code of the mainline
Linux kernel and submit patches to fix integer errors \sys reports.

\autoref{f:data:linux} summarizes the results.  The names for most
columns are self-explanatory.  ``Description'' shows the attack
vector and what values are infected.  ``\# of prev. fixes'' shows
the number of previous commits that tried to fix the same error but
didn't do it correctly.  ``Patch accepted?'' shows how the kernel
developers respond to our patches, as follows.
%We additional specify which repository the patch goes
%into, e.g., (net-next), if that patch has not reached the mainline.
\begin{itemize}
\item
\ok: the kernel developers accepted the patch upstream.
\item
Modified: the kernel developers modified our patch for inclusion.
\item
Acked: the kernel developers acknowledged the bug,
but we cannot find the patch showing up in any repository.
\item
Fixed: we withdrew the patch because the bug discovered in the
mainline was already fixed in some other repository.
\end{itemize}
We omit patches that does not get further responses. [[[numbers?]]]

\begin{figure*}
\centering
\footnotesize
\input{data/linux}
\caption{Integer errors found in the latest Linux kernel by \sys.}
\label{f:data:linux}
\end{figure*}

User-space applications.

Currently \sys's annotations and ranking heuristics are tailored
for the Linux kernel.  We only run \sys against two popular user-space
applications.  The developers have promptly fixed 5 integer errors
reported by \sys: 1 for lighttpd and 4 for OpenSSH.

\subsection{Common Pitfalls}

miss sanity checks.

char$\to$int: 
CA-1996-22,
Apache,
lighttpd new bug

bad overflow checks: $x \times y < x$, 
\autoref{f:bridge}.

compilers and arch:
signed overflow (IntegerLib, etc.),
oversized shift (Google's Native Client sandboxing),
ABI on 64-bit S/390, PowerPC, SPARC, and MIPS
and 32-bit system call parameters~\cite[CVE-2009-0029]{cve}

pivot in binary search.

index checks:
miss (i < 0) or should declare i as unsigned

return values: (ret < 0)
should declare ret as signed.

\subsection{Microbenchmark}
\label{s:eval:micro}

\autoref{f:udiv} shows a microbenchmark that measures the solving
time of the three checking forms of 32- and 64-bit integers,
respectively.  Each test is repeated 1000 times.  For a single
unsigned division operation this optimization can achieve up to
2.5$\times$ speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of $\uintmax(n) /_u x > y$ and two variant
forms: $2n$-bit multiplication and the multiplication overflow
detection circuit, measured in milliseconds, for both 32- and 64-bit
integers.}
\label{f:udiv}
\end{figure}

\subsection{Patching}

What do patches look like?

simple sanity check.
- return -EINVAL or silently limit the value (e.g., timeout).

interface change (e.g., CVE-2009-2909)
sometimes infeasible if the interface is exposed to userspace.

misread specification (CAN bits).


