\section{Evaluation}
\label{s:eval}

The evaluation answers the following questions:
\begin{CompactItemize}
\item
Is \sys effective in discovering new integer errors?
\item
How complete are \sys's reports?
\item
How many false errors are in \sys's reports?
\item
How long does it take \sys to analyze a large system such
as the Linux kernel?
\end{CompactItemize}

All the experiments were conducted on a 64-bit Ubuntu Linux machine
with an Intel Core i7-980 3.3~GHz CPU and 24~GB of memory.  The
processor has 6 cores, and each core has 2 hardware threads.

We periodically applied \sys to the latest Linux kernel
from November 2011 (v3.2) to April 2012 (v3.4-rc4),
and submitted patches according to \sys's reports.
The kernel developers confirmed and fixed \nrbugslinux integer errors.
%
We also applied \sys to two popular user-space applications, lighttpd
and OpenSSH; the developers fixed respectively \nrbugslighttpd and \nrbugsopenssh
integer errors reported by \sys.
%
The results show that \sys is effective in finding new integer
errors, and the developers are willing to fix them.  The rest
of this subsection explores the bugs found in Linux in more detail.

The integer errors \sys found span a wide range of kernel subsystems,
including the core kernel, device drivers, file systems, and network
protocols.
72 out of the 100 errors affect both 32-bit and 64-bit architectures;
23 errors are specific to 32-bit architecure, and the other 5 are 
specific to 64-bit architecure.
%The core kernel has fewer integer errors, since it does not
%interact with the outside as frequently as the rest of the kernel.

Multiplication appears to be the most error-prone operation; it is
often used for calculating allocation size, such as $n \times
\cc{sizeof}(...)$.  This use is vulnerable if $n$ can be controlled
by an adversary, causing the allocation size to wrap around to an
unanticipated smaller value.

Surprisingly,  a simple tautological expression that 
compares an unsigned integer with 0 ($<_u 0$, usually for error handling),
affected several subsystems.
The wl128x driver alone contains 36 such bugs, effectively
disabling most of its error handling paths.

Integer errors that allow out-of-bounds writes (i.e., buffer
overflow) would break the integrity of the kernel and potentially
enable privilege escalation attacks.  They can be exploited via network,
local access, or malformed filesystem on disk.  We see a large number of
such errors in \cc{ioctl}, an infamous error-prone interface.
%
There are also two interesting vulnerabilities in the sound subsystem;
an adversary can exploit them by plugging in a malicious USB audio
device that responds with bogus sampling rates, leading to kernel
hang, DoS, or buffer overflow.

Integer errors cause timing bugs in several network protocol
implementations.  For example, when a user space application provides
a large timeout argument, the internal timer can wrap around
to a smaller timeout value.

Most logic related integer errors are due to tautological comparisons.
These bugs would effectively disable error handling, or make the kernel
behave in unanticipated ways. 

\sys also found two logic bugs that were caused by programmer's
confusion. One example from \cc{net/can} is shown below.
\input{code/can}
The intent of the code is to test whether the error counter \cc{errc}
has reached certain level.  However, this
comparison will never be true because the left-hand side of the test,
which extracts 7 bits from \cc{errc}, is at most
$2^7 - 1 = 127$.  The fix is to check the right bit according to the
specification, using $\cc{errc}\ \&\ \cc{0x80}$.

Two integer errors (in xenbus and sctp) turned out
to be non-exploitable.  The kernel developers still applied our
patches for clarification and reliability improvement.

%
It is worth noting that \sys found bugs in two previous patches that
intended to fix vulnerabilities reported in the CVE list. 
These patches received extensive review. We describe them below.

\paragraph{CVE-2009-4307 (ext4).}
Below is the fix that performs a sanity check
on \cc{s_log_groups_per_flex} to prevent a division-by-zero DoS attack
when its value (read from disk) is large
and the result of the shift becomes zero.
\input{code/ext4-bad}
The fix turns out to be incorrect. 
In the sanity check, the value of \cc{groups_per_flex}
comes from a shift with a possible oversized amount.
%This would lead to two potential
%issues.
%
%First,
For example, when \cc{s_log_groups_per_flex} is set to 36,
$1 \shl 36$ is essentially $1 \shl 4 = 16$, 
since on x86 the shifting instruction truncates the amount to 5~bits.
This will bypass the check, leaving the two values
\cc{s_log_groups_per_flex}~(36) and \cc{groups_per_flex}~(16)
inconsistent.

Second, the C compiler may rewrite undefined code in unexpected
ways.  Consider the following equivalent sanity check (which was
in the originally proposed patch), assuming \cc{groups_per_flex}
is an unsigned integer.
\input{code/ext4-badeqv}
We compiled the code using both Clang~3.0 and GCC~4.6, with optimization
option \cc{-O2}.  Clang optimizes away the check
$\cc{groups_per_flex} == 0$, since it considers the case impossible,
following the C standard.  This would make the patched code as
vulnerable as the original.  GCC~4.6 keeps the check, but
there is no guarantee that future versions will do the same.

CVE-2012-2100 was assigned to this imperfect fix after we submitted
a new patch, which performs the check
$\cc{sbi->s_log_groups_per_flex} > 31$ before the shift.

\paragraph{CVE-2008-3526 (sctp).}
Below is the fix that performs a sanity check on \cc{key_len} to
avoid an integer overflow and possible heap overflow if
\cc{key_len} is large.
\input{code/sctp-bad}
This fix does not work.  Consider $\cc{key_len} =
\cc{0xffffffff}$ (i.e., \cc{UINT_MAX}).
The result of the left-hand side of the check is then \cc{0x80000000}.
Since \cc{key_len} is unsigned,  the left-hand side result
is also treated as unsigned (i.e., $2^{31}$), which bypasses the check.

After discussion with the kernel developers, we came to the conclusion
that \cc{key_len} could not become that large, so that CVE-2008-3526 is
not exploitable, and the fix is unnecessary. Our patch was applied to 
clarify the case.
