\section{Evaluation}
\label{s:eval}

The evaluation tries to answer the following questions.
\begin{itemize}
\item
Is \sys effective to discover integer errors in practice?
\item
How complete will \sys report integer errors?
\end{itemize}

All the experiments are conducted on a 64-bit Ubuntu Linux machine
equipped with Intel 3.2~G HZ CPU and 24~GB memory.

\subsection{Case Study: Linux}
\label{s:eval:linux}

We periodically run \sys against the source code of the mainline
Linux kernel and submit patches to the kernel developers.  \sys has
discovered more than 50 integer errors in a wide range of kernel
subsystems, including the core kernel, drivers, file systems, and
network protocols.

\autoref{f:data:linux} summarizes our experience.  Each line
represents a patchset that fixes one or more integer errors; the
number is shown in the ``Error'' column if it is more than one.  We
organize the patchsets based on the source directories.  Most
columns are self-explanatory.  ``Description'' shows the attack
vector and what values are infected.  ``\# of prev. fixes'' shows
the number of previous commits that tried to fix the same error but
didn't do it correctly.  ``Patch accepted?'' shows how the kernel
developers respond to our patches, in one of the following cases.
\begin{itemize}
\item
\ok: the kernel developers accepted the patch upstream.  We
additionally specify the original repository that contains the
patch, such as (xen), if the patch has not been merged into the
mainline.
\item
modified: the kernel developers modified our patch for inclusion.
\item
acked: the kernel developers acknowledged the patch, but they
did not apply it for unknown reason.
\item
fixed: the bug was already fixed in some repository other than the
mainline when \sys discovered it, so we withdraw our patch.
\end{itemize}
We omit patches that do not receive further responses.

\begin{figure*}
\centering
\footnotesize
\input{data/linux}
\caption{Integer errors discovered by \sys in the latest Linux
kernel source trees.  Each line is a patchset that tries to fix one
or more bugs (the number is in the ``Error'' column if more than
one).  For each patchset, we list the corresponding component, the
error operation with the number of bugs, the security impact, a
description of the attack vector and affected values, the number
of previous commits that did not to fix the same problem correctly,
and how the kernel developers respond to the patchset.}
\label{f:data:linux}
\end{figure*}

\subsubsection{Impact}

Error-handling related bugs would make the kernel behave in
unanticipated ways, though they are hard to be exploited from the
outside.  Most of these bugs are a simple tautological comparison.
One driver (wl128x) contains 36 such bugs alone, effectively disabling
almost its entire error handling mechanism.

An interesting non-trivial bug is due to specification misread in
CAN, where \sys detects a tautological comparison:
\begin{align*}
((\cc{errc}\ \&\ \cc{0x7f}) \shr 8) > 127.
\end{align*}
The intent of the code is to test whether the error counter has
reached certain level but did it in a wrong way.  However, this
comparison will never be true because the left-hand side is at most
127.  The fix is to read the right bit according to the specification,
via $\cc{errc}\ \&\ \cc{0x80}$.

Timing issues, as mostly seen in network protocols, would confuse
user-space applications with a wrong timeout.

The vulnerabilities that allow out-out-bounds writes (i.e., buffer
overflow) would break the integrity of the kernel and potentially
allow privilege escalation.  They can be exploited via local access,
disk (malformed filesystem), and network.  We see a large portion
of \cc{ioctl} since it is error-prone and biased by \sys's ranking
heuristics.  We also have an interesting vulnerability in the sound
subsystem; it can be exploited via plugging in a malicious USB audio
device that responds with bogus sampling rates, leading to kernel
hang, DoS, and buffer overflow.

Two cases (in xen and sctp, respectively) turn out to be non-exploitable.
The kernel developers still apply our patches for clarification and
reliability improvement.

\subsubsection{Bad Patches}

\sys discovers 7 integer errors that were previously known but fixed
incorrectly, one of which was fixed three times, still ending up
with buggy code.  Here we count the incorrect patches that were
committed into the mainline repository, not to mention those
bad patches proposed in the mailing list.
%Actually the kernel developers challenged three of our submitted patches,
%and proposed different solutions, all of which have been proven wrong
%and withrawn.

It is interesting that two cases were reported on the CVE list,
which we expect to have been reviewed comprehensively by the
community.  We describe them below.

\paragraph{CVE-2008-3526 (sctp).}
Below is the fix that performs a sanity check on \cc{key_len} to
avoid an integer overflow and possible heap overflow.
\input{code/sctp-bad}
If \cc{key_len} can get large, this sanity check does not actually
work.  Consider $\cc{key_len} = \cc{0xf0000000}$, i.e., $\cc{INT_MAX}
+ 1$.  The left-hand side is then $-1$.  Notice that the right-hand
side is unsigned, thus the comparison is unsigned, too, and the
left-hand side value $-1$ is treated as $2^{32} - 1$, which bypasses
the check.

Fortunately, after discussing with the kernel developers, we come
to a conclusion that \cc{key_len} cannot become that large with
input either from user space or network.  This CVE-2008-3526 is not
exploitable, and the previous commit is unnecessary.  Our patch is
applied to clarify the case.

\paragraph{CVE-2009-4307 (ext4).}
Below is the fix to avoid a division-by-zero DoS via a crafted
\cc{s_log_groups_per_flex} value from disk.
\input{code/ext4-bad}
The sanity check $(\cc{groups_per_flex} < 2)$ relies on undefined
behavior, an oversized shift.  This would lead to two potential
issues.

First, when \cc{s_log_groups_per_flex} is set to a corrupted value
like 36, $\cc{groups_per_flex} = 1 \shl 36$ is essentially $1 \shl
4 = 16$ on x86, rather than 0.  This will bypass the check, leaving
the two values \cc{s_log_groups_per_flex} and \cc{groups_per_flex}
inconsistent.

Second, the C compiler may rewrite undefined code in unexpected
ways.  Consider the following equivalent sanity check (which was
in the originally proposed patch), assuming \cc{groups_per_flex}
is an unsigned integer.
\input{code/ext4-badeqv}
We compile the code using both Clang~3.0 and GCC~4.6, with optimization
option \cc{-O2}.  Clang completely optimizes away the check
$\cc{groups_per_flex} == 0$, since it considers the case impossible
according to the C standard.  This would make the patched code as
vulnerable as the original.  GCC~4.6 still keeps the check, but
there is no guarantee that future versions will do the same.

\subsubsection{Performance}

To measure the performance, we run \sys against the Linux kernel
3.2 source code, on 12 CPU cores in parallel.  We set the timeout
to 5 seconds for each constraint solving.   \sys analyzes 8637 files,
10 of which timeouts, and makes 411,851 solving queries.  The
analysis (excluding compilation) takes 22 minutes to finish.

\subsection{Case Study: User-Space Applications}

Currently \sys's annotations and ranking heuristics are tailored
for the Linux kernel.
%
We only run \sys against two popular user-space applications,
lighttpd and OpenSSH.  The developers have promptly fixed 5 integer
errors reported by \sys: 1 in lighttpd and 4 in OpenSSH.  We omit
the details here.  See \autoref{s:common} for a summary of
common error patterns.

\subsection{Completeness Validation}

We have collected 36 integer errors in the Linux kernel from the
CVE list~\cite{cve} in recent three years as a benchmark to evaluate
\sys's completeness, as shown in \autoref{f:data:cve}.  They provide
a fairly comprehensive coverage of the whole source tree.  For each
case, we run \sys against both the original and the patched code
snippets.  Ideally \sys should catch the bugs in the original code,
while declare that the bug is fixed in the patched code.

\begin{figure*}
\centering
\footnotesize
\input{data/cve}
\caption{The result of applying \sys to integer errors in Linux
kernel from the CVE list.  Each test case consists of two parts:
the original and the patched code snippets.  We list the corresponding
component, the error operations, whether \sys catches the expected
bugs in the original code, and does not report the bug in the patched
code.}
\label{f:data:cve}
\end{figure*}

\subsubsection{Missed Bugs}

\sys is able to find 34 (94\%) out of the 36 integer errors, while
misses only two cases.  We detail them below.

\paragraph{CVE-2009-4307 (ext4).}
This bug is due to a possible division by zero that is caused by
an oversized left shift on PowerPC.  \sys is able to catch the
oversized shift, but not the division by zero, because in \sys's
semantics a left shift never produces zero, as discussed in
\autoref{s:sema:def}.

\paragraph{CVE-2010-3865 (rds).}
This bug is due to an addition overflow that happens in an accumulation
loop.  \sys cannot catch the bug since it unrolls the loop only
once.

\subsubsection{False and New Bugs}

When running against the patched code, \sys declares no bug in 29
cases, timeouts in 1 case, and still reports errors in 6 cases.
We analyze them below.

There is one false error in CVE-2011-4097 (oom).  Below is the code
snippet.  It is used when the kernel is running out of memory, to
compute a score for a process $p$ based on its memory consumption.
If $p$ gets a higher score, it is more likely to be killed by the
kernel in order to free more memory.
\input{code/oom}
The computation is basically to sum up the different numbers of
memory pages $p$ takes, and divide the result by the total number
of pages to get the ratio, which is scaled by 1000.  The patch
changes the type of \cc{points} from \cc{int} to \cc{from} because
\cc{points} could be large on 64-bit systems and multiplying it by
1000 could overflow.  This results in a process one that consumes
a lot of memory getting a low score; an innocent process would be
killed instead.

There is an implicit rule that the sum of these numbers of pages
(e.g., from \cc{get_mm_rss}) is at most \cc{totalpages}, so the
additions never overflow.  \sys does not understand the rule and
reports false errors on these additions.

In the remaining five cases, the patched code of CVE-2010-3873 (x25)
contains additional integer errors that are covered by CVE-2010-4164.
The other four contain either new errors or wrong patches revealed
by \sys, as we have shown in \autoref{s:eval:linux}.

\subsection{Microbenchmark}
\label{s:eval:micro}

As discussed in \autoref{s:gen:opt}, \sys rewrites error checking
idioms for better performance.  Here we measure the solving time
of three forms: division, multiplication, and overflow detection
circuit, for both 32- and 64-integers, respectively.  The result
is shown in \autoref{f:udiv}.  Each test is repeated 1000 times.
For a single unsigned division operation this optimization can
achieve up to 2.5$\times$ speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of $\uintmax(n) /_u x > y$ and two variant
forms: $2n$-bit multiplication and the multiplication overflow
detection circuit, measured in milliseconds, for both 32- and 64-bit
integers.}
\label{f:udiv}
\end{figure}
