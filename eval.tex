\section{Evaluation}
\label{s:eval}

The evaluation tries to answer the following questions.
\begin{itemize}
\item
Is \sys effective to discover integer errors in practice?
\item
How complete will \sys report integer errors?
\end{itemize}

All the experiments are conducted on a 64-bit machine equipped with
Intel 3.2~G HZ CPU and 24~G memory.

\subsection{Case Study: Linux}
\label{s:eval:linux}

We periodically run \sys against the source code of the mainline
Linux kernel and submit patches to the kernel developers.  \sys has
discovered more than 50 integer errors in a wide range of kernel
subsystems, including the core kernel, drivers, file systems, and
network protocols.

\autoref{f:data:linux} summarizes our experience.  Each line
represents a patchset that fixes one or more integer errors; the
number is shown in the ``Error'' column if it is more than one.  We
organize the patchsets based on the source directories.  Most
columns are self-explanatory.  ``Description'' shows the attack
vector and what values are infected.  ``\# of prev. fixes'' shows
the number of previous commits that tried to fix the same error but
didn't do it correctly.  ``Patch accepted?'' shows how the kernel
developers respond to our patches, in one of the following cases.
\begin{itemize}
\item
\ok: the kernel developers accepted the patch upstream.  We
additionally specify the original repository that contains the
patch, such as (xen), if the patch has not been merged into the
mainline.
\item
modified: the kernel developers modified our patch for inclusion.
\item
acked: the kernel developers acknowledged the patch, but they
did not apply it for unknown reason.
\item
fixed: the bug was already fixed in some repository other than the
mainline when \sys discovered it, so we withdraw our patch.
\end{itemize}
We omit patches that do not receive further responses.

\begin{figure*}
\centering
\footnotesize
\input{data/linux}
\caption{Integer errors discovered by \sys in the latest Linux
kernel source trees.  Each line is a patchset that tries to fix one
or more bugs (the number is in the ``Error'' column if more than
one).  For each patchset, we list the corresponding component, the
error operation with the number of bugs, the security impact, a
description of the attack vector and affected values, the number
of previous commits that did not to fix the same problem correctly,
and how the kernel developers respond to the patchset.}
\label{f:data:linux}
\end{figure*}

\subsubsection{Security Impact}

Not every integer error has security issues.  Those error-handling
logic bugs would make the kernel behave in unanticipated ways, but
are hard to control from the outside.  Timing issues, as mostly
seen in network protocols, would confuse user-space applications
with a wrong timeout.

The security bugs discovered by \sys can be exploited via local
access, disk (malformed filesystem), and network.  We see a large
portion of \cc{ioctl} since it is error-prone and biased by \sys's
ranking heuristics.  We also have an interesting vulnerability in
the sound subsystem; it can be exploited via plugging in a malicious
USB audio device that responds with bogus sampling rates, leading
to kernel hang, DoS, buffer overflow, and potential privilege
escalation.

Two cases (in xen and sctp, respectively) turn out to be non-exploitable.
The kernel developers still apply our patches for clarification and
realiability improvement.

\subsubsection{Bad Patches}

\sys discovers 7 integer errors that were previously known but fixed
incorrectly, one of which was fixed three times, still ending up
with buggy code.

It is interesting that two cases were reported on the CVE list,
which we expect to have been reviewed comprehensively by the
community.  We describe them below.

\paragraph{CVE-2008-3526 (sctp).}
Below is the fix that performs a sanity check on \cc{key_len} to
avoid an integer overflow and possible heap overflow.
\input{code/sctp-bad}
If \cc{key_len} get get large, this sanity check does not actually
work.  Consider $\cc{key_len} = \cc{0xf0000000}$, i.e., $\cc{INT_MAX}
+ 1$.  The left-hand side is then $-1$.  Notice that the right-hand
side is unsigned, thus the comparison is unsigned, too, and the
left-hand side value $-1$ is treated as $2^{32} - 1$, which bypasses
the check.

Fortunately, after discussing with the kernel developers, we come
to a conclusion that \cc{key_len} cannot become that large with
input either from user space or network.  This CVE-2008-3526 is not
exploitable, and the previous commit is unnecessary.  Our patch is
applied to clarify the case.

\paragraph{CVE-2009-4307 (ext4).}
Below is the fix to avoid a division-by-zero DoS via a crafted
\cc{s_log_groups_per_flex} value from disk.
\input{code/ext4-bad}
The sanity check $(\cc{groups_per_flex} < 2)$ relies on an oversized
shift, which is undefined behavior in C.  This would lead to two
potential issues.

First, when \cc{s_log_groups_per_flex} is set to a corrupted value
like 36, $\cc{groups_per_flex} = 1 \shl 36$ is essentially $1 \shl
4 = 16$ on x86, rather than 0.  This will bypass the check, leaving
the two values \cc{s_log_groups_per_flex} and \cc{groups_per_flex}
inconsistent.

Second, the C compiler may rewrite undefined code in unexpected
ways.  Consider the following equivalent sanity check (which was
in the originally proposed patch), assuming \cc{groups_per_flex}
is an unsigned integer.
\input{code/ext4-badeqv}
We compile the code using both Clang~3.0 and GCC~4.6, with optimization
option \cc{-O2}.  Clang completely optimizes away the check
$\cc{groups_per_flex} == 0$, since it considers the case impossible
according to the C standard.  This would make the patched code as
vulnerable as the original.  GCC~4.6 still keeps the check, but
there is no guarantee that future versions will do the same.

\subsubsection{Performance}

To measure the performance, we run \sys against the Linux kernel
3.2 source code, on 12 CPU cores in parallel.  We set the timeout
to 5 seconds for each constraint solving.   \sys analyzes 8637 files,
10 of which timeouts, and makes 411,851 solving queries.  The
analysis (excluding compilation) takes 22 minutes to finish.

\subsection{Case Study: User-Space Applications}

Currently \sys's annotations and ranking heuristics are tailored
for the Linux kernel.  We only run \sys against two popular user-space
applications.  The developers have promptly fixed 5 integer errors
reported by \sys: 1 for lighttpd and 4 for OpenSSH.  We omit the
details here.  See \autoref{s:eval:common} for a summary of common
error patterns.

\subsection{Completeness Validation}

We have collected 36 integer errors in the Linux kernel from the
CVE list~\cite{cve} in recent three years as a benchmark to evaluate
\sys's completeness, as shown in \autoref{f:data:cve}.  They provide
a fairly comprehensive coverage of the whole source tree.  For each
case, we run \sys against both the original and the patched code
snippets.  Ideally \sys should catch the bugs in the original code,
while declare that the bug is fixed in the patched code.

\begin{figure*}
\centering
\footnotesize
\input{data/cve}
\caption{The result of applying \sys to integer errors in Linux
kernel from the CVE list.  Each test case consists of two parts:
the original and the patched code snippets.  We list the corresponding
component, the error operations, whether \sys catches the expected
bugs in the original code, and does not report the bug in the patched
code.}
\label{f:data:cve}
\end{figure*}

\subsubsection{Missed Bugs}

\sys is able to find 34 (94\%) out of the 36 integer errors, while
misses only two cases.  We detail them below.

\paragraph{CVE-2009-4307 (ext4).}
The integer error is in the code for mounting the ext4 filesystem.
\input{code/ext4-bad}
Here \cc{sbi->s_log_groups_per_flex} could be assigned an integer
larger than 31 if read from a corrupted filesystem.  On PowerPC
this would cause \cc{groups_per_flex} to become zero due to the
shift.  It then leads to a division-by-zero bug in the subsequent
use as a divisor.

\sys is able to detect the oversized shift, but does not catch the
division by zero, because in \sys's semantics the shift never
produces zero, as discussed in \autoref{s:sema:def}.

\paragraph{CVE-2010-3865 (rds).}
This bug in due to an addition overflow that happens in an accumulation
loop.  \sys cannot catch the bug since it unrolls the loop only
once.

\subsubsection{False and New Bugs}

When running against the patched code, \sys declares no bug in 29
cases, timeouts in 1 case, and still reports errors in 6 cases.
We analyze them below.

There is one false error in CVE-2011-4097 (oom).  Below is the code
snippet.  It is used when the kernel is running out of memory, to
compute a score for a process $p$ based on its memory consumption.
If $p$ gets a higher score, it is more likely to be killed by the
kernel in order to free more memory.
\input{code/oom}
The computation is basically to sum up the different numbers of
memory pages $p$ takes, and divide the result by the total number
of pages to get the ratio, which is scaled by 1000.  The patch
changes the type of \cc{points} from \cc{int} to \cc{from} because
\cc{points} could be large on 64-bit systems and multiplying it by
1000 could overflow.  This results in a process one that consumes
a lot of memory getting a low score; an innocent process would be
killed instead.

There is an implicit rule that the sum of these numbers of pages
(e.g., from \cc{get_mm_rss}) is at most \cc{totalpages}, so the
additions never overflow.  \sys does not understand the rule and
reports false errors on these additions.

In the remaining five cases, the patched code of CVE-2010-3873 (x25)
contains additional integer errors that are covered by CVE-2010-4164.
The other four contain either new errors or wrong patches revealed
by \sys, as we have shown in \autoref{s:eval:linux}.

\subsection{Common Pitfalls}
\label{s:eval:common}

miss sanity checks.

char$\to$int: 
CA-1996-22,
Apache,
lighttpd new bug

bad overflow checks: $x \times y < x$, 
\autoref{f:bridge}.

compilers and arch:
signed overflow (IntegerLib, etc.),
oversized shift (Google's Native Client sandboxing),
ABI on 64-bit S/390, PowerPC, SPARC, and MIPS
and 32-bit system call parameters~\cite[CVE-2009-0029]{cve}

pivot in binary search.

index checks:
miss (i < 0) or should declare i as unsigned

return values: (ret < 0)
should declare ret as signed.

\subsection{Microbenchmark}
\label{s:eval:micro}

\autoref{f:udiv} shows a microbenchmark that measures the solving
time of the three checking forms of 32- and 64-bit integers,
respectively.  Each test is repeated 1000 times.  For a single
unsigned division operation this optimization can achieve up to
2.5$\times$ speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of $\uintmax(n) /_u x > y$ and two variant
forms: $2n$-bit multiplication and the multiplication overflow
detection circuit, measured in milliseconds, for both 32- and 64-bit
integers.}
\label{f:udiv}
\end{figure}

\subsection{Patching}

What do patches look like?

simple sanity check.
- return -EINVAL or silently limit the value (e.g., timeout).

interface change (e.g., CVE-2009-2909)
sometimes infeasible if the interface is exposed to userspace.

misread specification (CAN bits).

malloc $\to$ calloc

choose the right type (and sign).

use the correct check.

type promotion.

separate error code with bad values
