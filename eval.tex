\section{Evaluation}
\label{s:eval}

The evaluation tries to answer the following questions.
\begin{itemize}
\item
Is \sys effective to discover integer errors in practice?
\item
How complete will \sys report integer errors?
\end{itemize}

All the experiments are conducted on a 64-bit machine equipped with
Intel 3.2~G HZ CPU and 24~G memory.

\subsection{Case Study: Linux}
\label{s:eval:linux}

We periodically run \sys against the source code of the mainline
Linux kernel and submit patches to the kernel developers.
\autoref{f:data:linux} summarizes our experience.  Each line
represents a patchset that fixes one or more integer errors; the
number is shown in the ``Error'' column if it is more than one.  We
organize the patchsets based on the source directories.  Most
columns are self-explanatory.  ``Description'' shows the attack
vector and what values are infected.  ``\# of prev. fixes'' shows
the number of previous commits that tried to fix the same error but
didn't do it correctly.  ``Patch accepted?'' shows how the kernel
developers respond to our patches, in one of the following cases.
\begin{itemize}
\item
\ok: the kernel developers accepted the patch upstream.  We
additionally specify the original repository that contains the
patch,  such as (xen), if the patch has not shown up in the mainline.
\item
modified: the kernel developers modified our patch for inclusion.
\item
acked: the kernel developers acknowledged the bug,
but we cannot find the patch showing up in any repository.
\item
fixed: we withdrew the patch because the bug discovered in the
mainline was already fixed in some other repository.
\end{itemize}
We omit XXX patches that do not get further responses.

\begin{figure*}
\centering
\footnotesize
\input{data/linux}
\caption{Integer errors discovered by \sys in the latest Linux
kernel source trees.  Each line is a patchset that tries to fix one
or more bugs (the number is in the ``Error'' column if more than
one).  For each patchset, we list the corresponding component, the
error operation with the number of bugs, the security impact, a
description of the attack vector and affected values, the number
of previous commits that did not to fix the same problem correctly,
and how the kernel developers respond to the patchset.}
\label{f:data:linux}
\end{figure*}

We can see that \sys has discovered integer errors in a wide range
of kernel subsystems, including the memory management, drivers,
file systems, and network protocols.


\paragraph{Bad fixes.}
It is worth noting that six integer errors were fixed incorrectly
at least once before; one was fixed twice and another was fixed
three times, still ending up with buggy code.  We will show two
examples below.

\paragraph{Attack vectors.}

Two of the integer errors reported by \sys turn out to be not
exploitable.

\paragraph{Performance.}
To measure the performance, we run \sys against the Linux kernel
3.2 source code, on 12 CPU cores in parallel.  We set the timeout
to 5 seconds for each constraint solving.   \sys analyzes 8637 files,
10 of which timeouts, and makes 411,851 solving queries.  The
analysis (excluding compilation) takes 22 minutes to finish.

\subsection{Case Study: User-Space Applications}

Currently \sys's annotations and ranking heuristics are tailored
for the Linux kernel.  We only run \sys against two popular user-space
applications.  The developers have promptly fixed 5 integer errors
reported by \sys: 1 for lighttpd and 4 for OpenSSH.  See
\autoref{s:eval:common} for a summarization of common error patterns.

\subsection{Completeness Validation}

We have collected 36 integer errors in the Linux kernel from the
CVE list~\cite{cve} in recent three years as a benchmark to evaluate
\sys's completeness, as shown in \autoref{f:data:cve}.  They provide
a fairly comprehensive coverage of the whole source tree.  For each
case, we run \sys against both the original and the patched code
snippets.  Ideally \sys should catch the bugs in the original code,
while declare that the bug is fixed in the patched code.

\begin{figure*}
\centering
\footnotesize
\input{data/cve}
\caption{The result of applying \sys to integer errors in Linux
kernel from the CVE list.  Each test case consists of two parts:
the original and the patched code snippets.  We list the corresponding
component, the error operations, whether \sys catches the expected
bugs in the original code, and does not report the bug in the patched
code.}
\label{f:data:cve}
\end{figure*}

\subsubsection{Missed Bugs}

\sys is able to find 34 (94\%) out of the 36 integer errors, while
misses only two cases.  We detail them below.

\paragraph{CVE-2009-4307 (ext4).}
The integer error is in the code for mounting the ext4 filesystem.
\input{code/ext4-2009-4307}
Here \cc{sbi->s_log_groups_per_flex} could be assigned an integer
larger than 31 if read from a corrupted filesystem.  On PowerPC
this would cause \cc{groups_per_flex} to become zero due to the
shift.  It then leads to a division-by-zero bug in the subsequent
use as a divisor.

\sys is able to detect the oversized shift, but does not catch the
division by zero, because in \sys's semantics the shift never
produces zero, as discussed in \autoref{s:sema:def}.

\paragraph{CVE-2010-3865 (rds).}
This bug in due to an addition overflow that happens in an accumulation
loop.  \sys cannot catch the bug since it unrolls the loop only
once.

\subsubsection{False and New Bugs}

When running against the patched code, \sys declares no bug in 29
cases, timeouts in 1 case, and still reports errors in 6 cases.
We analyze them below.

There is one false error in CVE-2011-4097 (oom).  Below is the code
snippet.  It is used when the kernel is running out of memory, to
compute a score for a process $p$ based on its memory consumption.
If $p$ gets a higher score, it is more likely to be killed by the
kernel in order to free more memory.
\input{code/oom}
The computation is basically to sum up the different numbers of
memory pages $p$ takes, and divide the result by the total number
of pages to get the ratio, which is scaled by 1000.  The patch
changes the type of \cc{points} from \cc{int} to \cc{from} because
\cc{points} could be large on 64-bit systems and multiplying it by
1000 could overflow.  This results in a process one that consumes
a lot of memory getting a low score; an innocent process would be
killed instead.

There is an implicit rule that the sum of these numbers of pages
(e.g., from \cc{get_mm_rss}) is at most \cc{totalpages}, so the
additions never overflow.  \sys does not understand the rule and
reports false errors on these additions.

In the remaining five cases, the patched code of CVE-2010-3873 (x25)
contains known integer errors, which are further covered by
CVE-2010-4164.
The patched code of CVE-2009-4307 (ext4), however, uses undefined
code to fix the problem, as shown below.
\input{code/ext4-bad}
Since \cc{sbi->s_log_groups_per_flex} could be a corrupted value
from disk, the computation of \cc{groups_per_flex} relies on an
oversized shift, which is undefined according to the C standard.
This would lead to two potential problems.

First, setting \cc{sbi->s_log_groups_per_flex} to a corrupted value
such as 36 may bypass the sanity check on architectures other than
PowerPC.  For example $(1 \shl 36)$ is equivalent to $(1 \shl 4)$
on x86.  This would leave an inconsistency between these parameters.

Second, the C compiler may rewrite undefined code is an unexpected
way.  Consider the following sanity check, which is equivalent to
$\cc{groups_per_flex} < 2$, assuming \cc{groups_per_flex} is an
unsigned integer.
\input{code/ext4-badeqv}
We compile the code using two C compilers, Clang~3.0 and GCC~4.6,
with optimization option \cc{-O2}.  Clang completely optimizes away
the check $\cc{groups_per_flex} == 0$, since it considers the case
impossible according to the C standard.  This would make the patched
code as vulnerable as the original.  GCC~4.6 still keeps the check,
but it is possible that future versions perform the same optimization.

The other three cases contain either new errors or the patch
is wrong, as we have shown in \autoref{s:eval:linux}.

\subsection{Common Pitfalls}
\label{s:eval:common}

miss sanity checks.

char$\to$int: 
CA-1996-22,
Apache,
lighttpd new bug

bad overflow checks: $x \times y < x$, 
\autoref{f:bridge}.

compilers and arch:
signed overflow (IntegerLib, etc.),
oversized shift (Google's Native Client sandboxing),
ABI on 64-bit S/390, PowerPC, SPARC, and MIPS
and 32-bit system call parameters~\cite[CVE-2009-0029]{cve}

pivot in binary search.

index checks:
miss (i < 0) or should declare i as unsigned

return values: (ret < 0)
should declare ret as signed.

\subsection{Microbenchmark}
\label{s:eval:micro}

\autoref{f:udiv} shows a microbenchmark that measures the solving
time of the three checking forms of 32- and 64-bit integers,
respectively.  Each test is repeated 1000 times.  For a single
unsigned division operation this optimization can achieve up to
2.5$\times$ speedup.

\begin{figure}
\centering
\input{data/udiv}
\caption{Solving time of $\uintmax(n) /_u x > y$ and two variant
forms: $2n$-bit multiplication and the multiplication overflow
detection circuit, measured in milliseconds, for both 32- and 64-bit
integers.}
\label{f:udiv}
\end{figure}

\subsection{Patching}

What do patches look like?

simple sanity check.
- return -EINVAL or silently limit the value (e.g., timeout).

interface change (e.g., CVE-2009-2909)
sometimes infeasible if the interface is exposed to userspace.

misread specification (CAN bits).

malloc $\to$ calloc

choose the right type (and sign).

use the correct check.

type promotion.

separate error code with bad values
