\section{Integer Semantics}
\label{s:sema}

We define \sys's integer semantics via the security requirement of
each integer operation.  Any integer operation that violates the
security requirement implies an error, unless the operation is in
the white list of code patterns that \sys explicitly allows.

\subsection{Secure Integer Operations}
\label{s:sema:sec}

\sys assumes two's complement~\cite[\chapterautorefname~4.2.1]{intel:vol1},
a de facto standard integer representation on modern architectures.
An $n$-bit unsigned integer is in the range $0$ to $2^n-1$, while
an $n$-bit signed integer is in the range $-2^{n-1}$ to $2^{n-1}-1$,
with the most significant bit indicating the sign.  An operation
may have a subscript $s$ or $u$ to indicate whether it operates on
signed or unsigned integers, respectively.

\paragraph{Addition \& subtraction \& multiplication.}
The result of an additive or multiplicative operation should fall
in the predefined range.  For example,
$\cc{0xf0000000}\times_u 16$ is insecure,
because the expected product $2^{32}\times
3\times 5$ is out of the range of $32$-bit unsigned integers~($0$
to $2^{32} - 1$).

\paragraph{Division.}
The divisor should be non-zero,
and the result should fall in the predefined range.
Particularly, $-2^{n-1} /_s {-1}$ is insecure,
because the expected quotient $2^{n-1}$ is out of
the range of $n$-bit signed integers~($-2^{n-1}$ to $2^{n-1}-1$).

\paragraph{Shift.}
For $n$-bit integers, the shifting amount should be non-negative
and at most $n-1$.  Otherwise, the operation is undefined according
to the C standard.  For example, for 32-bit integers, $1 \shl 32$ yields 1
on x86 and 0 on PowerPC.  \sys considers the operation as an integer
error.

\paragraph{Conversion.}
Lossy truncations and sign conversions are often seen in C
code, and they can be found by invoking GCC with \cc{-Wconversion}.
\sys does not impose any restrictions on a conversion,
unless its result is used in one of the following two cases:

\paragraph{$(1)$ Comparison.}
A comparison should not be always true or false (i.e., tautological
comparison) due to an integer conversion, which disables part of
the control flow.

For example, in \autoref{f:ext4} the call to \cc{ext4_split_extent}
returns a signed integer, which will be negative on error.  However,
the return value is converted to an unsigned integer for comparison,
leading to a stale expression $\cc{allocated} <_u 0$ that always
evaluates to false and disables the error handling.

\begin{figure}
\centering
\input{code/ext4}
\vspace{-1em}
\caption{An integer error in the ext4 filesystem of the Linux kernel.
Since \cc{allocated} is declared as \cc{unsigned int}, the test
$(\cc{allocated} < 0)$ will always be false, which breaks the
error handling logic.}
\label{f:ext4}
\end{figure}

\paragraph{$(2)$ Non-negative value.}
A variable that represents a data size or an array index should be
non-negative.

\autoref{f:ax25-sign} shows an example in the Linux kernel.
The third parameter of $\cc{copy_from_user}(\cc{dst}, \cc{src},
\cc{size})$ should be non-negative since it indicates the number
of bytes to be copied from user space to kernel.  However, an
adversary could supply $-1$ for \cc{optlen} from user space, which
will bypass both sanity checks because the value is interpreted as
unsigned in the first comparison and signed in the second.  
The negative \cc{optlen} is later used in the call to \cc{copy_from_user}
as the size parameter, which flags an integer error.

\begin{figure}
\centering
\input{code/ax25-sign}
\vspace{-1em}
\caption{An integer error (CVE-2009-2909) in the AX.25
network protocol implementation of the Linux kernel.  A negative
\cc{optlen} will bypass both sanity checks due to sign misinterpretation
 and trigger an kernel
oops in the subsequent \cc{copy_from_user} call.}
\label{f:ax25-sign}
\end{figure}

\subsection{Equivalence}
\label{s:sema:eqv}

It is worth noting that two functionally equivalent operations at
the machine instruction level may have different integer semantics.
For example, $\cc{maxnum}\times_u 16$ and $\cc{maxnum} \shl 4$ are
identical instructions, but the former expression causes an integer
error if \cc{maxnum} is large, while the latter one is considered
always secure.  \sys assumes that the developer has chosen the
intended integer operation.

Any compiler optimization that rewrites
$\cc{maxnum}\times_u 16$ to $\cc{maxnum} \shl 4$ will destroy the
integer semantics.  Even worse, C compilers like GCC may completely
optimize away checks like $(x + 1) < x$ if $x$ is a signed integer
or a pointer~\cite{gcc:signed-overflow,us-cert:gcc}, unless a special
option \cc{-fwrapv} or \cc{-fno-strict-overflow} is
given.  To avoid the interference, \sys is designed to run before
these optimizations.

\subsection{Default Semantics}
\label{s:sema:def}

Signed integer overflows and oversized shifts are undefined according
to the C language standard.  In order to continue evaluating
expressions like $x \times_s y + z$ after $x \times_s y$ overflows,
\sys defines the default semantics for these integer operations, as
follows:
\begin{itemize}
\item
For $n$-bit signed arithmetic operations, \sys assumes the wrapping
semantics as if they were unsigned (i.e., $\mod{2^n}$), which is
the same as invoking GCC with the \cc{-fwrapv} option.
\item
Division by zero is undefined.  \sys does not consider the result
in further expressions.
\item
For shifts, \sys assumes x86's semantics, using $\log_2 n$ bits for
shifting an $n$-bit integer.  That is, it uses 5~bits of the shift
amount for 32-bit shifts, e.g., $1 \shl 32 = 1 \shl 0 = 1$.  This semantics
is also the behavior of ARM and MIPS processors.
\end{itemize}
\sys may miss integer errors that are not modeled by the above
semantics.  Consider the expression $x / (1 \shl y)$, where $x$ and
$y$ are unconstrained 32-bit integers.  \sys will be able to detect
the oversized shift, but not the division by zero, since
with \sys's default semantics $1 \shl y$ cannot be zero.

\subsection{White Listing Idioms}
\label{s:sema:whitelist}

Developers often use overflowed results to defend against integer
overflows.  \sys recognizes such idioms and avoid reporting them
as integer errors, as listed in \autoref{f:whitelist}.  For example,
given two $n$-bit unsigned integers $x$ and $y$, a popular overflow
checking idiom is as follows:
\begin{equation*}
x +_u y <_u x.
\end{equation*}
This idiom is useful when the sum is needed later in the code.
Let $\uintmax(n)$ denote the largest $n$-bit unsigned integer (i.e.,
$2^n - 1$).  Below is an equivalent non-overflow form.
\begin{equation*}
\uintmax(n) -_u x >_u y.
\end{equation*}

Note that \sys does not recognize the overflowed comparison $x
\times_u y <_u x$ as a valid integer error check.  For example,
given $x = \cc{0x1fffffff}$ and $y = 16$, their product evaluates
to a larger value $\cc{0xfffffff0}$, which both overflows and
bypasses the check.  A correct check is $(x \times_u y) /_u y \neq
x$, or an non-overflow form, $\uintmax(n) /_u x > y$.

In addition, \sys accepts user-provided idioms tailored for the
code being analyzed.  For example, in the Linux kernel to set a
timer that expires after \cc{delay} ticks one often invokes
\cc{mod_timer(..., jiffies + delay)}, where \cc{jiffies} is the
number of ticks since the machine started.  \sys recognizes
this idiom and ignores the addition \cc{jiffies + delay} that may
theoretically overflow.

\begin{figure}
\centering
\begin{tabular}{ll}
\toprule
Overflowed check & Equivalent check \\ \midrule
$x + y <_u x$ & $x >_u \uintmax(n) - y$ \\
$x - y <_s 0$ & $x <_u y$ \\
$(x \times y) /_u y \neq x$ & $x >_u \uintmax(n) /_u y$   \\
\bottomrule
\end{tabular}
\caption{Examples of overflowed check idioms that \sys recognizes.
Here $\uintmax(n)$ denotes the largest $n$-bit unsigned integer.}
\label{f:whitelist}
\end{figure}
