\section{Integer Semantics}
\label{s:sema}

We define \sys's integer semantics via the security requirement of
each integer operation.  Any integer operation that violates the
security requirement implies an error, unless the operation is in
the white list of code patterns that \sys explicitly allows.

\subsection{Secure Integer Operations}
\label{s:sema:sec}

\sys assumes two's complement~\cite[\chapterautorefname~4.2.1]{intel:vol1},
a de facto standard integer representation on modern architectures.
An $n$-bit unsigned integer is in the range $0$ to $2^n-1$, while
an $n$-bit signed integer is in the range $-2^{n-1}$ to $2^{n-1}-1$,
with the most significant bit indicating the sign.  An operation
may have a subscript $s$ or $u$ to indicate whether it operates on
signed or unsigned integers, respectively.

\paragraph{Addition, subtraction, and multiplication.}
The arithmetic result of an additive or multiplicative operation should fall
in the range of the result type.  For example,
$2^{31}\times_u 16$ is insecure,
because the expected arithmetic product $2^{35}$ is out of the range
of $32$-bit unsigned integers~($0$ to $2^{32} - 1$).

\paragraph{Division.}
The divisor should be non-zero,
and the arithmetic result should fall in the range of the result type.
Particularly, $-2^{n-1} /_s {-1}$ is insecure,
because the expected arithmetic quotient $2^{n-1}$ is out of
the range of $n$-bit signed integers~($-2^{n-1}$ to $2^{n-1}-1$).

\paragraph{Shift.}
For $n$-bit integers, the shifting amount should be non-negative
and at most $n-1$, otherwise the operation is undefined according
to the C standard.
%For example, for 32-bit integers, $1 \shl 32$ yields 1
%on x86 and 0 on PowerPC.
\sys considers an oversized shift as an integer error.

\paragraph{Conversion.}
Lossy truncations and sign conversions are common practice in
C code.  Therefore,
%, and they can be found by invoking GCC with \cc{-Wconversion}.
\sys does not impose any restrictions on a conversion,
unless its result is used in one of the following cases:

\paragraph{$(1)$ Comparison.}
A comparison should not be always true or false (i.e., tautological
comparison) due to an integer conversion, which otherwise would
disable part of the control flow.

For example, in \autoref{f:olpc-sign} the intent of the comparison
$\cc{status == -1}$ was to check whether \cc{read_status} returns
${-1}$.  However, since the function returns an unsigned 8-bit
integer, which is zero-extended to \cc{int} according to C's
conversion rules, \cc{status} is non-negative.  Consequently,
the comparison always evaluates to false, which disables the error
handling.

\begin{figure}
\centering
\input{code/olpc-sign}
\vspace{-1em}
\caption{An integer error in the OLPC secondary display controller
driver of the Linux kernel.  Since \cc{->read_status()} returns an
unsigned 8-bit integer, the value of \cc{status} is in the range
$[0, 255]$.  Comparing \cc{status} with ${-1}$ will always be false,
which breaks the error handling.}
\label{f:olpc-sign}
\end{figure}

\paragraph{$(2)$ Array index.}
An array index should be non-negative,
otherwise it would lead to out-of-bounds access.

\paragraph{$(3)$ Data size.}
A data size should be non-negative, otherwise it would be misinterpreted
as a large positive value and lead to out-of-bounds access.

\autoref{f:ax25-sign} shows an example of a negative size in the
Linux kernel.  The third parameter of $\cc{copy_from_user}$ should
be non-negative since it indicates the number of bytes to be copied
from user space to kernel.  However, an adversary could supply
${-1}$ for \cc{optlen} from user space, which will bypass both
sanity checks:
according C's conversion rules, \cc{optlen} is interpreted as positive
in the first comparison because the type of the right-hand side
\cc{sizeof(int)} is unsigned, while it is still considered as
negative in the second comparison because the type of the right-hand
side \cc{IFRAMESIZ} is signed.
The negative \cc{optlen} is later used in the call to \cc{copy_from_user}
as the size parameter, which flags an integer error.

\begin{figure}
\centering
\input{code/ax25-sign}
\vspace{-1em}
\caption{An integer error in the AX.25 network protocol implementation
of the Linux kernel (CVE-2009-2909).  A negative \cc{optlen} will
bypass both sanity checks due to sign misinterpretation and reach
the \cc{copy_from_user} call, which interprets \cc{optlen}
as a large positive integer.  Depending on the architecture-specific
implementation, the consequences range from a silent failure, a
kernel oops, to a stack overflow.
}
\label{f:ax25-sign}
\end{figure}

\subsection{Equivalence}
\label{s:sema:eqv}

It is worth noting that two functionally equivalent operations at
the machine instruction level may have different integer semantics
in \sys.
For example, $\cc{maxnum}\times_u 16$ and $\cc{maxnum} \shl 4$ are
identical instructions, but the former expression causes an integer
error if \cc{maxnum} is large, while the latter one is considered
always secure.  \sys assumes that the developer uses the
arithmetically intended integer operation. \nz{``intended'' is vague.}

Any compiler optimization that rewrites
$\cc{maxnum}\times_u 16$ to $\cc{maxnum} \shl 4$ will destroy the
integer semantics.  Even worse, C compilers like GCC may completely
optimize away checks like $(x + 1) < x$ if $x$ is a signed integer
or a pointer~\cite{gcc:signed-overflow,us-cert:gcc}, unless a special
option \cc{-fwrapv} or \cc{-fno-strict-overflow} is
given.  To avoid the interference, \sys is designed to run before
these optimizations.

\subsection{Default Semantics}
\label{s:sema:def}

Signed integer overflows and oversized shifts are undefined according
to the C language standard.  In order to continue evaluating
expressions like $x \times_s y + z$ after $x \times_s y$ overflows,
\sys defines the default semantics for these integer operations, as
follows:
\begin{itemize}
\item
For $n$-bit signed arithmetic operations, \sys assumes the wrapping
semantics as if they were unsigned (i.e., $\mod{2^n}$), which is
the same as invoking GCC with the \cc{-fwrapv} option.
\item
Division by zero is undefined.  \sys does not consider the result
in further expressions.
\item
For shifts, \sys assumes x86's semantics, using $\log_2 n$ bits for
shifting an $n$-bit integer.  That is, it uses 5~bits of the shift
amount for 32-bit shifts, e.g., $1 \shl 32 = 1 \shl 0 = 1$.  This semantics
is also the behavior of ARM and MIPS processors.
\nz{Why does this matter?  KINT semantics already flag an oversized
shift as an error, so why do we need to continue reasoning about the
precise value that an oversized shift expression will have?}
\end{itemize}
\sys may miss integer errors that are not modeled by the above
semantics.  Consider the expression $x / (1 \shl y)$, where $x$ and
$y$ are unconstrained 32-bit integers.  \sys will be able to detect
the oversized shift, but not the division by zero, since
with \sys's default semantics $1 \shl y$ cannot be zero.

\subsection{White Listing Idioms}
\label{s:sema:whitelist}

Developers often use overflowed results to defend against integer
overflows.  \sys recognizes such idioms and avoid reporting them
as integer errors, as listed in \autoref{f:whitelist}.  For example,
given two $n$-bit unsigned integers $x$ and $y$, a popular overflow
checking idiom is as follows:
\begin{equation*}
x +_u y <_u x.
\end{equation*}
This idiom is useful when the sum is needed later in the code.
Let $\uintmax(n)$ denote the largest $n$-bit unsigned integer (i.e.,
$2^n - 1$).  Below is an equivalent non-overflow form.
\begin{equation*}
\uintmax(n) -_u x >_u y.
\end{equation*}

Note that \sys does not recognize the overflowed comparison $x
\times_u y <_u x$ as a valid integer error check.  For example,
given $x = \cc{0x1fffffff}$ and $y = 16$, their product evaluates
to a larger value $\cc{0xfffffff0}$, which both overflows and
bypasses the check.  A correct check is $(x \times_u y) /_u y \neq
x$, or an non-overflow form, $\uintmax(n) /_u x > y$.

In addition, \sys accepts user-provided idioms tailored for the
code being analyzed.  For example, in the Linux kernel to set a
timer that expires after \cc{delay} ticks one often invokes
\cc{mod_timer(..., jiffies + delay)}, where \cc{jiffies} is the
number of ticks since the machine started.  \sys recognizes
this idiom and ignores the addition \cc{jiffies + delay} that may
theoretically overflow.
\nz{What does this spec look like?  Do you literally allow the
ASCII string ``jiffies + delay'', or do you allow a more general
pattern?  How general?  ``jiffies + *''?  Or ``jiffies + *'' in
the last argument of {\tt mod\_timer}?}

\begin{figure}
\centering
\begin{tabular}{ll}
\toprule
Overflowed check & Equivalent check \\ \midrule
$x + y <_u x$ & $x >_u \uintmax(n) - y$ \\
$x - y <_s 0$ & $x <_u y$ \\
$(x \times y) /_u y \neq x$ & $x >_u \uintmax(n) /_u y$   \\
\bottomrule
\end{tabular}
\caption{Examples of overflowed check idioms that \sys recognizes.
Here $\uintmax(n)$ denotes the largest $n$-bit unsigned integer.}
\label{f:whitelist}
\end{figure}
