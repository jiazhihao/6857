\section{Integer Semantics}
\label{s:sema}

We define \sys's integer semantics via error constraints.  The error
constraint of an integer operation is a Boolean predicate if satisfied
implies an integer error, unless the operation is in the white list
of code patterns that \sys explicitly allows.

\subsection{Error Constraint}
\label{s:sema:constr}

\sys assumes two's complement~\cite[\chapterautorefname~4.2.1]{intel:vol1},
a de facto standard integer representation on modern architectures.
An $n$-bit unsigned integer is in the range $0$ to $2^n-1$, while
an $n$-bit signed integer is in the range $-2^{n-1}$ to $2^{n-1}-1$,
with the most significant bit indicating the sign.  An operation
may have a subscript $s$ or $u$ to indicate whether it operates on
signed or unsigned integers, respectively.

\if 0
\sys adopts the CERT C secure coding guidelines for integer
operations~\cite[\chapterautorefname~5]{seacord:secure-c} as a basis
and considers violations of the guidelines as integer errors.  These
violations cover a set of integer-based vulnerabilities, sometimes
referred as arithmetic overflow (underflow, wraparound), division-by-zero,
oversized shift, and signedness bugs in the literature.  We summarize
them below.
\fi

\paragraph{Addition \& subtraction \& multiplication.}
An additive or multiplicative operation may lead to an integer error
if the result falls out of the predefined range.  For example,
$\cc{maxnum}\times_u 16$ causes an integer error if $\cc{maxnum} =
\cc{0xf0000000}$, because $\cc{0xf0000000} \times 16 = 2^{32}\times
3\times 5$ is out of the range of $32$-bit unsigned integers ($0$
to $2^{32} - 1$).

\paragraph{Division.}
A division operation causes an integer error if the divisor is 0.
Additionally, signed division $x\ /_s\ y$ may lead to an integer
error if $x = -2^{n-1}$ and $y = -1$, because $2^{n-1}$ is not in
the range of $n$-bit signed integers ($-2^{n-1}$ to $2^{n-1}-1$).

\paragraph{Shift.}
The bitwise shifts $x \shl y$ and $x \shr y$ are considered as
integer errors if $y \geq_u n$, which is undefined according to the
C standard.  As for 32-bit integers, $(1 \shl 32)$ yields 1 on x86
and 0 on PowerPC.

\paragraph{Conversion.}
Lossy truncations and sign conversions are often seen in systems
code, and they can be found by invoking GCC with \cc{-Wconversion}.
\sys does not consider such a conversion as an integer error, unless
its result is used in one of the following two cases.

\paragraph{$(1)$ Tautological comparison.}
A comparison is always true or false due to an integer conversion,
which means that the result from the conversion voids one of the
branches.

For example, in \autoref{f:ext4} the call to \cc{ext4_split_extent}
returns a signed integer, which will be negative on error.  However,
the return value is converted to an unsigned integer for comparison,
leading to a stale expression $\cc{allocated} <_u 0$ that always
evaluates to false.

\begin{figure}
\centering
\input{code/ext4}
\vspace{-1em}
\caption{An integer error in the ext4 filesystem of the Linux kernel.
Since \cc{allocated} is declared as \cc{unsigned int}, the test
$(\cc{allocated} < 0)$ will always be false, which breaks the
error handling logic.}
\label{f:ext4}
\end{figure}

\paragraph{$(2)$ Negative count.}
An integer that should always be non-negative is to be negative.
Such conceptually non-negative cases including array indices and
``size'' function parameters.

\autoref{f:ax25-sign} shows such an example in the Linux kernel.
The third parameter of $\cc{copy_from_user}(\cc{dst}, \cc{src},
\cc{size})$ should be non-negative since it indicates the number
of bytes to be copied from user space to kernel.  However, an
adversary could supply $-1$ for \cc{optlen} from user space, which
will bypass both sanity checks because the value is interpreted as
unsigned in the first comparison and signed in the second.  \cc{optlen}
is later used in the call to \cc{copy_from_user} as the size
parameter, which flags an integer error since \cc{optlen} is negative.

\begin{figure}
\centering
\input{code/ax25-sign}
\vspace{-1em}
\caption{An integer error~\cite[CVE-2009-2909]{cve} in the AX.25
network protocol implementation of the Linux kernel.  A negative
\cc{optlen} will bypass both sanity checks due to sign misinterpretation
 and trigger an kernel
oops in the subsequent \cc{copy_from_user} call.}
\label{f:ax25-sign}
\end{figure}

\subsection{Equivalence}
\label{s:sema:eqv}

It is worth noting that two functionally equivalent operations at
the machine instruction level may have different integer semantics.
For example, $\cc{maxnum}\times_u 16$ and $\cc{maxnum} \shl 4$ are
identical instructions, but the former expression causes an integer
error if \cc{maxnum} is large, while the latter one is considered
always safe.  \sys assumes that the developer has chosen the
intended integer operation.

Any compiler optimization that rewrites
$\cc{maxnum}\times_u 16$ to $\cc{maxnum} \shl 4$ will destroy the
integer semantics.  Even worse, C compilers like GCC may completely
optimize away checks like $(x + 1) < x$ if $x$ is a signed integer
or a pointer~\cite{gcc:signed-overflow,us-cert:gcc}, unless a special
option \cc{-fwrapv} or \cc{-fno-strict-overflow} is
given.  To generate error constraints that best match the developer's
intention, \sys is designed to run before these optimizations.

\subsection{Default Semantics}
\label{s:sema:def}

Signed integer overflows and oversized shifts are undefined according
to the C language standard.  In order to continue evaluating
expressions like $x \times_s y + z$ after $x \times_s y$ overflows,
\sys defines the default semantics for these integer operations, as
follows:
\begin{itemize}
\item
For $n$-bit signed arithmetic operations, \sys assumes the wrapping
semantics as if they were unsigned (i.e., $\mod{2^n}$), which is
the same as invoking GCC with the \cc{-fwrapv} option.
\item
Division by zero is undefined.
\item
For shifts, \sys assumes x86's semantics, using $\log_2 n$ bits for
shifting an $n$-bit integer.  That is, it uses 5~bits of the shift
amount for 32-bit shifts, e.g., $1 \shl 32 = 1$.  This semantics
is also the behavior of ARM and MIPS processors.
\end{itemize}
\sys may miss integer errors that are not modeled by the above
semantics.  Consider the expression $x / (1 \shl y)$, where $x$ and
$y$ are unconstrained 32-bit integers.  \sys will be able to detect
the oversized shift via error constraint $y \geq_u 32$.  However,
it will miss the division-by-zero error, which is possible on PowerPC
but not on x86.

\subsection{White Listing Idioms}
\label{s:sema:whitelist}

It is commonly seen in practice to use an overflowed result to do
the integer error check for $x +_u y$, where both $x$ and $y$ are
$n$-bit unsigned integers, as follows:
\begin{equation*}
x +_u y <_u x.
\end{equation*}
This idiom is useful when the sum is needed later in the code.
\sys recognizes such idioms listed in \autoref{f:whitelist} and
does not consider them as integer errors.

An equivalent non-overflow form of each overflowed check idiom is
also shown for comparison.  Let $\uintmax(n)$ denote the largest
$n$-bit unsigned integer, i.e., $2^n - 1$.  Below is a non-overflow
version of addition overflow check:
\begin{equation*}
\uintmax(n) - x >_u y.
\end{equation*}

Note that \sys does not recognize the overflowed comparison $x
\times_u y <_u x$ as a valid integer error check.  For example,
given $\cc{maxnum} = \cc{0x1fffffff}$, $\cc{maxnum} \times_u 16$
evaluates to a larger value $\cc{0xfffffff0}$, which both overflows
and bypasses the check.  A correct check is $(x \times_u y) /_u y
\neq x$, or an non-overflow form, $\uintmax(n) /_u x > y$.

The imperfect check does not always lead to a security vulnerability.
In the above example, \cc{maxnum} has to be at least $2^{28}$ to
overflow $\cc{maxnum} \times 16$, and the product must be greater
than or equal to that to bypass the check $\cc{maxnum} \times_u 16
<_u \cc{maxnum}$.  Allocating $2^{28}$ bytes (i.e., 256~MB) is
possible in a user-space application, but unlikely to succeed in
the Linux kernel with \cc{kmalloc}, which imposes a relatively small
limit~\cite[\chapterautorefname~8]{ldd3}.  In that case, \sys
would report a false error.

Another error-prone check is using an oversized shift like $(1 \shl
n) = 0$ to detect a large $n$.  As mentioned in \autoref{s:sema:constr},
its value will never be 0 on architectures like x86, which fails
the check.  The C compiler may even rewrite the check as a no-op.
\sys does not consider the check as a valid checking idiom.

In addition, \sys accepts user-provided idioms tailored for the
code being analyzed.  For example, in the Linux kernel to set a
timer that expires after \cc{delay} ticks one often invokes
\cc{mod_timer(..., jiffies + delay)}, where \cc{jiffies} is the
number of ticks since the machine started.  \sys recognizes
this idiom and ignores the addition \cc{jiffies + delay} that may
theoretically overflow.

\begin{figure}
\centering
\begin{tabular}{ll}
\toprule
Overflowed check & Equivalent check \\ \midrule
$x + y <_u x$ & $x >_u \uintmax(n) - y$ \\
$x - y <_s 0$ & $x <_u y$ \\
$(x \times y) /_u y \neq x$ & $x >_u \uintmax(n) /_u y$   \\
\bottomrule
\end{tabular}
\caption{Examples of overflowed check idioms that \sys recognizes.
Here $\uintmax(n)$ denotes the largest $n$-bit unsigned integer.}
\label{f:whitelist}
\end{figure}

\if 0

\subsection{A Strawman Analysis}

Consider a \naive analysis that generates constraints from both the
error and path preconditions.  As for the multiplication $\cc{maxnum}
\times_u 16$ in \autoref{f:bridge}, \sys computes its error
precondition as:
\begin{equation*}
\cc{maxnum} >_u (2^{32} - 1) / 16.
\end{equation*}
Since the multiplication is always reachable without any branches
in that function, the corresponding path precondition is simply true.

\sys then feeds the logical AND of the two preconditions into a
constraint solver~\cite{boolector}.  The solver computes a possible
input, e.g., $\cc{maxnum} = \cc{0xf0000000}$.

Now let's consider the patched code that correctly limits \cc{maxnum}
to 256, shown as below (\cc{maxnum} is
numbered~\cite[\chapterautorefname~8.11]{whale} for clarification
purpose).
\input{code/bridge-p}
The error precondition of the multiplication remains unchanged.
\begin{equation*}
\cc{maxnum}_1 >_u (2^{32} - 1) / 16.
\end{equation*}
The corresponding path precondition is that \cc{maxnum} is reset to 256
if it is larger than 256, or remains the old value otherwise.
\begin{align*}
& ((\cc{maxnum}_0 >_u 256) \land (\cc{maxnum}_1 = 256)) \\
\lor
& (\neg (\cc{maxnum}_0 >_u 256) \land (\cc{maxnum}_1 = \cc{maxnum}_0)).
\end{align*}
Again \sys takes the logical AND of the two preconditions to the
constraint solver, which will conclude that these constraints can
never be satisfied.  This means that the integer error has been
fixed.

\subsection{Challenges}
\label{s:chal}

There are several challenges that face \sys when applying the
secure integer standard described in \autoref{s:goal} to real-world
systems code.

\subsubsection{Benign Integer Errors}

While violating the secure integer standard, some commonly-used C
idioms will not cause any defects.  We recognize them as follows.

\paragraph{Partial violation.}
Take $(x +_u 1) -_u 2$ with $x \geq_u 1$ for an example.  The
expression would be considered as an integer error since the first
part $(x +_u 1)$ may be insecure, though the whole expression is
equivalent to $x -_u 1$ and will not cause any integer error.
Another example is that signed and unsigned integers are often used
interchangeably in C code.  In a conversion like \cc{(int)((unsigned)x)}
for a signed $x <_s 0$, the part \cc{(unsigned)x} may violate the
secure integer standard while the whole expression does not.  \sys
should avoid to warn against such ``partial'' violations.

\paragraph{Error-before-use.}
An integer error check may come after the overflowed computation,
but before any use of the result.  In that case, the overflowed
computation is benign.  Below is such an example.
\input{code/error-before-use}
Even the multiplication $x \times_u y$ overflows, the product
\cc{size} is not used before the check.  \sys will move the integer
operation $x \times_u y$ down to the latest possible point, i.e.,
right after the \cc{if} branch and before the \cc{malloc} call, so
as to avoid warning against the multiplication.

\paragraph{Overflowed checking idiom.}
It is commonly seen in practice to use an overflowed result to do
the integer error check for $x +_u y$:
\begin{align}
x +_u y <_u x.
\end{align}
This is equivalent to a ``sane'' check
$\cc{UINT_MAX} - x >_u y$.
\sys should recognize such integer error checking idioms and avoid
to warn against them.

Note that using overflowed result to check multiplication is trickier.
In general $x \times_u y <_u x$ is not a valid integer error check
but a bug.  A correct way would be $(x \times_u y) /_u y \neq x$
or a sane check, $\cc{UINT_MAX} /_u x > y$.

\subsubsection{Constraint Solving Performance}

Although \sys uses a highly-optimized constraint solver,
constraints generated unwisely would still hurt its performance,
sometimes even making it run forever.

\paragraph{Bounded constraint size.}
It is not a good idea to naively analyze and generate constraints
interprocedurally, for example,  across the whole Linux kernel.
The size of the path constraint would grow exponentially, which is
unnecessary and hard to solve.  To achieve scalability, \sys should
choose an appropriate program granularity.

\sys also needs to handle complex program constructs such as loops
and pointer arithmetic appropriately.  The generated constraints
should be able to catch common integer errors while being solvable
in a reasonable amount of time.

\paragraph{Idioms for faster solving.}
We notice that some operations like division would significantly
slow down the constraint solver~\cite{brummayer:perf}, most of which
are used in integer error checks like $\cc{UINT_MAX} /_u x > y$.
\sys should recognize these idioms and generate constraints that
are easier to solve.

\fi
