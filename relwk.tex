\section{Related Work}
\label{s:relwk}

In the context of integer error analysis, \sys has a combination of 5 novel
properties: static analysis with pragmatic integer semantics, ability to scale
to large software, high precision, high coverage, and a new NaN integer family.
We relate \sys to previous work along these 5 properties.

\paragraph{Pragmatic integer semantics.} The closest work to \sys is a static integer overflow detection
tool inside Microsoft~\cite{moy:z3prefix}, which also uses constraint solving
techniques.  Compared to \sys, Microsoft's tool imposes too strict integer
semantics.

Consider the sign conversion below, a widely seen code pattern in
the Linux kernel.
\input{code/endian}
Note that \cc{le32_to_cpu} returns an unsigned 32-bit integer, which
is silently converted to the signed \cc{status} of the same size.
The Microsoft tool will issue a warning for the sign conversion if
the value returned from \cc{le32_to_cpu} can be as large as $2^{32}
- 1$, because $2^{32} - 1$ is out of the bounds of 32-bit signed
integers~(at most $2^{31} - 1$) and turns \cc{status} negative.
%
\sys does not flag every such conversion as an error.  \sys considers
the conversion as an error only if \cc{status} causes a comparison
to be always true or false, or a negative \cc{status} is used as
an array index or a data size~(see \autoref{s:sema:sec}).
%\sys additionally catches oversized shifts while the Microsoft tool does not.

\if 0
The Microsoft tool is implemented using the PREfix
engine~\cite{bush:prefix}.  It simulates execution along possible
code paths within a function, until reaching
the user-configured maximum number of paths (or finishing all paths
if the number of paths is small).
%
%\sys generates path predicates along the control flow
%to filter out infeasible code paths.
Compared to PREfix, \sys's algorithm is simpler
and covers all paths in a loop-free program.
\fi

In addition, \sys performs a set of effective analyses
tailored for integer error detection, which are missing in the
Microsoft tool.  For example, to reduce false errors, \sys infers
the value ranges of integral structure field across the whole
kernel~(see \autoref{s:gen:range}), and distinguishes integers coming
through untrusted channels that can be controlled by an adversary
from trusted ones~(see \autoref{s:rank}).
%tries to move predicates out of loops
%to catch more errors~(see \autoref{s:gen:path}) and rewrites
%error-before-check patterns to reduce false errors~(see
%\autoref{s:gen:opt}).

\if 0
The Microsoft tool implements approximations for multiplication
overflow checks, because the authors observed many timeouts in their
constraint solver.  \sys does precise bit-level reasoning
since we did not experience the issue.
\fi

%First, 
%it formalizes error constraints in a pragmatic way: rather
%than imposing constraints on every conversion~\cite{brumley:rich,
%moy:z3prefix, seacord:secure-c}, it catches tautological comparisons
%and negative counts instead.  Otherwise, the output would be flooded
%by noisy, innocuous conversion warnings~\cite{moy:z3prefix}.

\paragraph{Scalability.}
Symbolic model checking tools systematically explore code paths
for integer errors by treating input as symbolic values and pruning
infeasible paths via constraint solving.  Examples include
KLEE~\cite{cadar:klee},
LLBMC~\cite{llbmc},
SmartFuzz~\cite{molnar:catchconv},
and
IntScope~\cite{intscope}.

Applying these tools to the Linux kernel is challenging.  One would
have to model hardware devices, otherwise the corresponding driver
code will not load or function correctly.  The environment and
constraints are so complex that one may also have to split
individual modules for model checking~\cite{engler:vs}.  These
changes require too much manual effort, especially given the
large number of drivers and the rapid code changes in the Linux
kernel.  To avoid these complications \sys is a static analysis tool that
generates predicates carefully to allow it to scale to the Linux kernel, without
making any modifications to the Linux source code. \sys can be inserted into the
Linux compilation workflow transparently.

\paragraph{Precision.}
It is difficult for tools that do not track path conditions (e.g.,
sanity checks) to pinpoint integer errors.  For example, a simple
taint analysis that warns untrusted integers used in sensitive
sinks~(e.g., allocation)~\cite{cqual, lclint} would report false
errors on all correctly fixed code.

The range checker from Stanford's metacompiler~\cite{range-checker}
eliminates cases where a user-controlled value is checked against
\emph{some} bounds and reports unbounded integer usages.  A similar heuristic
is used in a PREfast-based tool from Microsoft~\cite{prefast}.  This
approach will miss integer errors due to incorrect bounds checking since
it does not perform reasoning on the actual values of the bounds. \sys avoids
these issues by generating carefully predicates that includes path conditions.

\paragraph{Coverage.}
Dynamic integer error detection tools,
including
GCC's \cc{-ftrapv},
RICH~\cite{brumley:rich},
Archerr~\cite{archerr},
IOC~\cite{ioc},
blip~\cite{blip},
and
IntPatch~\cite{intpatch},
insert integer error checks when generating code; any violation in
these checks will cause a trap at run time.
%
%Clang's \cc{-fcatch-undefined-behavior} option covers more undefined
%integer operations such as oversized shifts.
%
An alternative approach is to instrument binary executable files,
such as IntFinder~\cite{intfinder} and UQBTng~\cite{uqbtng}.
%
The advantage of these tools is that they have a lower false error rate.
Using them to find integer errors requires input that can trigger
those bugs, and thus it is in general difficult to achieve high
coverage.  In particular, because triggering integer errors often requires
carefully chosen input values.

\if 0
\paragraph{OS testing tools.}
OS testing tools aim at finding kernel bugs triggered by external input,
including system calls~(e.g., Trinity~\cite{trinity} and
iknowthis~\cite{iknowthis}) and malformed file systems~(e.g.,
FiSC~\cite{fisc:yang} and \textsc{eXplode}~\cite{explode:yang}).
They are not designed specifically for finding integer errors
but complement \sys.
\fi

%Rubio-Gonz\'alez et al.~\cite{eio} have developed a static analysis
%tool that detects incorrect error code in file system implementations.
\if 0
Carburizer~\cite{kadav:tolerating} analyzes driver code to find
potential bugs that can be triggered by misbehaved hardware devices.
\sys trusts most hardware devices and filters out the corresponding
integer errors, as we have explained in \autoref{s:rank}.  One could
disable the filter in \sys to find such bugs for improving reliability
of device code.
\fi

\if 0
As pointed out in \autoref{s:sema:eqv}, integer semantics
are \emph{not} preserved by compiler optimizations.
While \sys is designed to avoid destructive optimizations, tools that
work on binary executable files, either symbolic or not,
will suffer from this problem and will be unable to extract
precise integer security requirements.
\fi

\paragraph{Library and language support.}
To avoid integer errors, developers can adopt
an integer library with error checks, such as CERT's
IntegerLib~\cite[INT03-C]{seacord:secure-c}
and SafeInt~\cite{safeint}.
For example, developers
change their code by calling a library function $\cc{addsl}(x, y)$
to add two signed long integers $x$ and $y$.
The library then performs sanity checks at run time, and invokes a
preset error handler if an integer error happens.

%SafeInt~\cite{safeint} is a C++ template class widely used in Microsoft
%products and Mozilla Firefox.  It eases the adoption and allows to write
%the intuitive expression $x + y$ via operator overloading in C++;
%developers need to declare $x$ and $y$ as the \cc{SafeInt<long>}
%type.

The integer library is trusted to be implemented correctly.
Unfortunately, integer errors have recently been discovered in both
IntegerLib and SafeInt~\cite{ioc}.
%Below is IntegerLib's \cc{addsl} implementation.
%
%\input{code/addsl}
%We believe that there are two issues in the above code.
%
%First, \cc{sizeof(int)} should be \cc{sizeof(signed long)}, otherwise
%the code would trigger false alarms on a 64-bit system.  Second,
%the code relies on undefined behavior, i.e., signed overflow of
%\cc{lhs+rhs}, to defend against overflow.  A compiler may rewrite
%the code in unexpected ways.
\if 0
According to the C standard, signed integer overflows are undefined,
which allows the C compiler to rewrite the code in arbitrary ways.
GCC provides the option \cc{-fwrapv} to enforce the wrapping semantics
for signed integers.  The Linux kernel is compiled with a slightly
different option \cc{-fno-strict-overflow}, to prevent GCC from
optimizing away checks with signed integers (e.g., $x + 1 < x$) and
pointers (e.g., $p + \mathit{len} < p$).  These options reduce the
risk of undesirable optimizations.

Developers may also compile their code with the \cc{-ftrapv} option
using GCC, to enable traps for signed integer overflows at run time,
and write a signal handler to deal with the trap.
The main concern of enabling traps for production code
is that it introduces false alarms at run time, and there is no
convenient way for developers to provide fine-grained error handlers
if such an alarm is raised.  It also incurs noticeable runtime
overhead~\cite{ioc}, given the prevalence of integer operations.

The AIR model~\cite{air} delays integer errors until the error value
is used.  In the AIR model, it is acceptable to delay
catching integer semantic violations and raising traps, as long as the program's
behavior is the same as if all integers were infinitely ranged.
Developers, however, may intentionally use overflow operations like
$x + y < x$ to defend against integer errors; treating integers as
infinitely ranged would result in different behavior.
\fi

%Developers would benefit from language support for specifying precise
%lower and upper bounds of variables.  For example,
Ada provides language support
to define a ranged subtype (e.g., integers from 0 to 9).  The runtime
will raise an exception on any attempt to store an out-of-bounds
value to variables of that subtype, and developers are responsible
for handling the exception.  There is a similar proposal that adds
ranged integers to the C language~\cite{ranged-c}.  Our NaN integer family is
inspired by these designs.

\if 0
Another option is to use infinitely ranged integers (i.e., bignum),
if the code is not performance critical.  Scripting languages such
as Python and Ruby have built-in bignum support.  Using bignum is
generally more immune to integer errors since it does not wrap,
although the underlying bignum implementation, often written in C,
may contain integer vulnerabilities (e.g., CVE-2011-0188,
in Ruby's bignum implementation).
\fi
%shown as below.
%\input{code/ruby}

%We suspect that removing unsigned types from the language would
%not help reduce the risk of integer errors.  For example, Java
%supports only signed integers.  However, its binary search
%implementation contained an integer bug, which was not fixed until
%JDK~6~\cite{java-bsearch}.  The buggy code calculates the midpoint
%using $(\cc{low} + \cc{high})/2$, which will become negative for
%large $\cc{low}$ and $\cc{high}$.  A correct version is $\cc{low}
%+ (\cc{high}-\cc{low})/2$.  In the C language one may simply declare
%$\cc{low}$ and $\cc{high}$ as unsigned integers to avoid the problem.



%% Coverity?
%% http://www.coverity.com/library/pdf/Coverity_White_Paper-SAT-Next_Generation_Static_Analysis.pdf

