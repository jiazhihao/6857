\section{Related Work}
\label{s:relwk}

This section relates \sys to existing work.

\paragraph{Semantics.}
\sys's integer semantics differs from that used in previous integer
error detection tools in the following ways.

First, it formalizes error constraints in a pragmatic way: rather
than imposing constraints on every conversion~\cite{brumley:rich,
moy:prefix, seacord:secure-c}, it catches tautological comparisons
and negative counts instead.  Otherwise, the output would be flooded
by noisy, innocuous conversion warnings~\cite{moy:prefix}.

Second, as pointed out in \autoref{s:sema:eqv}, integer semantics
is \emph{not} preserved by the compiler during optimizations.  While
\sys is designed to avoid their destructive rewriting, tools that
detect integer errors on instrumented binary at run time will suffer
from this problem and not be able to extract correct
constraints~\cite{molnar:catchconv, intscope}.

The AIR model~\cite{air} provides a different approach of loosing
integer constraints.  In their model, it is acceptable to delay
catching integer semantic violations, as long as the program's
behavior is the same as if all integers were infinitely ranged.
However, developers may intentionally use overflow operations like
$x + y < x$ to defend against integer errors; treating integers as
infinitely ranged would observe a different behavior, which could
be amended using \sys's white list shown in \autoref{s:sema:whitelist}.

\paragraph{Analysis techniques.}

Constraint solving has been proven to be effective for bug detection,
as it offers precise bit-level reasoning of programs.  \sys, as
well as previous tools such as PREfix~\cite{moy:prefix} and
Saturn~\cite{xie:saturn}, benefits from this technique.  In addition,
\sys proposes a set of optimizations tailored for integer error
detection, as shown in \autoref{s:gen:opt}.

A simple integer error detection approach is to extend the type
system to distinguish trusted and untrusted integers, and then
perform taint analysis to warn untrusted integers used in sensitive
sinks~\cite{cqual, lclint}.  Since path conditions (e.g., sanity
checks) are not tracked, such tools would report false errors on
all correctly fixed code.

The range checker from Stanford's metacompiler~\cite{range-checker}
eliminates cases where a user-controlled value is checked against
\emph{some} bound and reports unbounded values.  A similar heuristic
is used in a Microsoft's tool based on PREfast~\cite{prefast}.  This
approach will miss integer errors due to incorrect bounds since
they do not perform precise reasoning.

Dynamic integer error detection tools,
including
RICH~\cite{brumley:rich},
Archerr~\cite{archerr},
IOC~\cite{ioc},
blip~\cite{blip},
and
IntPatch~\cite{intpatch},
extend GCC's \cc{-ftrapv} to insert trap code during compilation for
run time checking.
%
An alternative approach is to instrument binary executable files,
such as IntFinder~\cite{intfinder} and UQBTng~\cite{uqbtng}.
%
The advantage of these tools is that they have a lower false error rate.
Using them to find integer errors requires input that can trigger
those bugs, and thus it is in general difficult to achieve a high
coverage.

Symbolic model checking tools systematically explore code paths by
treating input as symbolic values and pruning infeasible paths via
constraint solving.  Examples include
KLEE~\cite{cadar:klee},
LLBMC~\cite{llbmc},
Catchconv~\cite{molnar:catchconv},
and
IntScope~\cite{intscope}.
Applying these tools to the Linux kernel is challenging.  One would
have to model hardware devices, otherwise the corresponding driver
code will not load or function correctly.  The environment and
constraints are so complex that one may also have to split
individual modules for model checking~\cite{engler:vs}.  These
preparations require too much manual effort, especially given the
large number of drivers and the rapid code changes in the Linux
kernel.

\paragraph{OS testing tools.}
OS testing tools that target on finding bugs in particular kernel
subsystems are a complement to \sys.

System call fuzzers such as Trinity~\cite{trinity} and
iknowthis~\cite{iknowthis} perform stress testing to detect
Linux kernel bugs that can be triggered via system calls.

FiSC~\cite{fisc:yang} and \textsc{eXplode}~\cite{explode:yang}
explore file system code via model checking to detect bugs that can
be triggered by malformed file systems.
%
Rubio-Gonz\'alez et al.~\cite{eio} have developed a static analysis
tool that detects incorrect error code in file system implementations.

Carburizer~\cite{kadav:tolerating} analyzes driver code to find
potential bugs that can be triggered by misbehaved hardware devices.
\sys trusts most hardware devices and filters out the corresponding
integer errors, as we have explained in \autoref{s:rank}.  One could
disable the filter in \sys to find such bugs for improving reliability
of device code.

\subsection{Alternative Integer Semantics}

Wrapping is the default behavior in languages like Java.
GCC provides the option \cc{-fwrapv} to enforce wrapping semantics
for signed integers in C code.  The Linux kernel is compiled with a
slightly different option \cc{-fno-strict-overflow}, to prevent GCC
from optimizing away checks with signed integers (e.g., $x + 1 <
x$) and pointers (e.g., $p + \mathit{len} < p$).
These options reduce the risk of unwanted optimizations.

A different strategy is trapping.  Ada raises an exception at run
time for out-of-range values.  For C, GCC provides the option
\cc{-ftrapv} to insert overflow checks for signed integer operations
in the generated code; any violation will cause a trap at run time.
This is extended by Clang via \cc{-fcatch-undefined-behavior} for
more undefined integer operations such as oversized shifts, and by
other compiler patches~\cite{brumley:rich, ioc} even for unsigned
integer overflows.  They are useful for detecting integer errors
at run time.

The main concern of enabling trapping semantics for production code
is that it introduces false alarms at run time, while there is no
convenient way for developers to provide fine-grained error handlers
if such an alarm is raised.  It also incurs noticeable runtime
overhead~\cite{ioc}, given the prevalence of integer operations.

\subsection{Using an Integer Library}

Another approach to secure the code is to enforce the use of an integer
library with error checks, such as CERT's
IntegerLib~\cite[INT03-C]{seacord:secure-c}.  For example, developers
change their code by calling a library function $\cc{addsl}(x, y)$
for addition of two signed long integers $x$ and $y$.  The library
then performs sanity checks at run time, and invokes a preset error
handler if an integer error happens.

SafeInt~\cite{safeint} is a C++ template class widely used in Microsoft
products and Mozilla Firefox.  It eases the adoption and allows to write
the intuitive expression $x + y$ via operator overloading in C++;
developers need to declare $x$ and $y$ as the \cc{SafeInt<long>}
type.

The underlying integer library is trusted to be implemented correctly.
Unfortunately, integer errors have recently been discovered in both
IntegerLib and SafeInt~\cite{ioc}.  Developers who adopt these
integer libraries should be aware any such issues.
%Below is IntegerLib's \cc{addsl} implementation.
%
%\input{code/addsl}
%We believe that there are two issues in the above code.
%
%First, \cc{sizeof(int)} should be \cc{sizeof(signed long)}, otherwise
%the code would trigger false alarms on a 64-bit system.  Second,
%the code relies on undefined behavior, i.e., signed overflow of
%\cc{lhs+rhs}, to defend against overflow.  A compiler may rewrite
%the code in unexpected ways.


\subsection{Language Design}

Developers would benefit from language support for specifying precise
lower and upper bounds of variables.  For example, Ada allows to
define a ranged subtype, e.g., integers from 0 to 9.  The runtime
will raise an exception for any attempt to storing an out-of-range
value to variables of that subtype, and developers are responsible
for handling the exception.  There is a similar proposal that adds
ranged integers to the C language~\cite{ranged-c}.

Another option is to use infinitely ranged integers, aka bignum,
if the code is not performance critical.  Scripting languages such
as Python and Ruby have built-in bignum support.  Using bignum is
generally more immune to integer errors since it does not wrap,
although the underlying bignum implementation, often written in C,
may contain vulnerabilities.  CVE-2011-0188 is a recent example in
Ruby's bignum, where an improper truncation may cause a buffer
overflow.
%shown as below.
%\input{code/ruby}

We suspect that removing unsigned types from the language would
not help reduce the risk of integer errors.  For example, Java
supports only signed integers.  However, its binary search
implementation contained an integer bug, which was not fixed until
JDK~6~\cite{java-bsearch}.  The buggy code calculates the midpoint
using $(\cc{low} + \cc{high})/2$, which will become negative for
large $\cc{low}$ and $\cc{high}$.  A correct version is $\cc{low}
+ (\cc{high}-\cc{low})/2$.  In the C language one may simply declare
$\cc{low}$ and $\cc{high}$ as unsigned integers to avoid the problem.
