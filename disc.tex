\section{Discussion}
\label{s:disc}

\subsection{Common Pitfalls}

miss sanity checks.

char$\to$int: 
CA-1996-22,
Apache,
lighttpd new bug

bad overflow checks: $x \times y < x$, 
\autoref{f:bridge}

index checks:
miss (i < 0) or should declare i as unsigned

return values: (ret < 0)
should declare ret as signed.

\subsection{Mitigation Strategies}

What developers can do?

malloc $\to$ calloc

choose the right type (and sign).

use the correct check.

type promotion.

The grsecurity~\cite{grsecurity} patch, aiming to enhance the
security of the Linux kernel, addresses the integer error issue
in \cc{kmalloc} calls by defining a macro of the same name.
%
\input{code/grsecurity-kmalloc}
%
Here \cc{intoverflow_t} is defined as the 128-bit unsigned integer
type.  The trick is that, assuming the developer often writes code
like \cc{kmalloc(n * sizeof(...))}, with the macro of the same name
the C preprocessor will silently change the call to
\cc{kmalloc((intoverflow_t)n * sizeof(...))}, where \cc{n} is first
promoted to 128 bits for the computation.  This should be large
enough to detect most integer errors.  However, it does not work
if the allocation size is already computed before being passed to
\cc{kmalloc}, such as in \autoref{f:bridge}.

when writing your own allocator, don't repeat the mistake that
happened in glibc and Microsoft's libc~\cite{rus-cert:calloc}.

separate error code with bad values

using a library?

\subsection{Language Design}

type-safe languages: not so exploitable, DoS more likely

bignum vs. fixed-width integers.

sign or not?

compiler support: warn common error patterns.

range annotations?  something like?
\begin{Verbatim}
#define RANGE(lo, hi) __attribute__((range(lo, hi)))
#define MAX_ELTS 1024

struct X {
	unsigned int nelts RANGE(1, MAX_ELTS);
	struct Y *elts;
};
\end{Verbatim}
Then you can do instrumentation on stores of nelts.
Better runtime checks \& good for static analysis.

