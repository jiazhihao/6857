\section{Mitigation Strategies}
\label{s:miti}

This section discusses mitigating integer errors
in C code.

\subsection{NaN Integer Semantics}

Writing integer error checks is tedious and error-prone.  Programmers
may forget to perform a check, or use wrong bounds that some inputs
can bypass. \xw{reference results from eval.}

Even for a simple multiplication \cc{n * size} that is often used
as a \cc{malloc} size, programmers need a non-trivial check \cc{(size
\&\& n > SIZE_MAX / size)}.  When the expression gets more complex,
programmers would have to write checks for every arithmetic operation.

To automate integer error checking, we propose a new
integer family that provides NaN semantics: an integer value goes
into error state (i.e., NaN) once it overflows, and remains NaN in
future computation.

The basic usage of NaN integers is to add a type qualifier \cc{nan}
to an actual integer type, such as \cc{nan size_t}.
\begin{itemize}
\item
An integer of type $T$ will be automatically promoted to $\cc{nan}\ T$
when used with an integer of type $\cc{nan}\ T$.
\item
The result type of an arithmetic or comparison operation with
operands of type $\cc{nan}\ T$ is also $\cc{nan}\ T$.
The result value is NaN if any source operand is NaN.
\end{itemize}

The NaN integer API consists of the following functions.
\begin{itemize}
\item
$\cc{bool}\ \cc{isnan}(\cc{nan}\ T x)$ \hfill (NaN testing) \\
returns true if $x$ is NaN, or false otherwise.
\item
$T\ \cc{unnan}(\cc{nan}\ T x, T v)$ \hfill (integer casting) \\
returns $v$ if $x$ is NaN, or $(T)x$ otherwise.
\end{itemize}
With the API, we modify \cc{malloc} to take an \cc{nan size_t} as
the allocation size and return \cc{NULL} if the size is NaN~(i.e.,
the calculation overflowed).

Below is an example use case.
\input{code/use-nan}
In this way, programmers do not have to write any overflow checks
when calculating the allocation size.

\begin{figure}
\centering
\small
\input{data/nan-micro}
\caption{Microbenchmark of performance overhead using manual overflow
checks and NaN integers, measured in cycles.}
\label{f:data:nan-micro}
\end{figure}

\if 0
Below is an example check in the infiniband driver.
\input{code/ib-check}
In the check, \cc{wqe_size}, \cc{wr_count}, and \cc{sqe_count} are
all directly from user space, and thus their values can be any
(32-bit) integers.  Carefully crafted values would overflow the
multiplications and addition at the right-hand side and bypass
check.  To avoid overflows, one would need to write additional
checks, such as:
\input{code/ib-more}
With NaN integers, one needs to change the type of
\cc{wqe_size}, \cc{wr_count}, and \cc{sqe_count} to NaN integers,
and wrap the original check with $\cc{nan}(\dots, \cc{true})$.
\input{code/ib-nan}
\fi

choose $2^n-1$ as the NaN.


e1000.

\subsection{Safe Array Allocator}

\xw{could move this part to an earlier point}

Multiplication for calculating allocation size seems particularly
prone to integer errors, particularly in the forms of \cc{kmalloc}\cc{(n
* size, ...)} if the code does not correctly bound \cc{n}.

\cc{kmalloc_array}.

\subsection{TBD}

Windows seems to enforce unsigned integers in kernel.

overflow builtins?

integer libraries?

buggy allocator?

\if 0

\subsection{Compiler Checking}

It would be useful to have the compiler check and warn against
integer errors, so that developers can fix these bugs
at compile time.  Ideally, the check should not slow down
the compilation too much, and the false error rate should be kept low,
so that developers are willing to enable the check.
%
Due to the above two concerns, one cannot directly integrate
\sys's solver-based approach into a compiler.  A pragmatic workaround
could be to match and warn against the common error patterns
summarized in \autoref{s:common}, which can be done efficiently
with a low false error rate.

Decent C compilers have some support for detecting integer error
patterns.
%
GCC provides \cc{-Wtype-limits} to warn if a comparison if always
true or false due to type range limits.
%however this
%option is not turned on even with \cc{-Wall}, probably because of
%its high false rate.
%
Clang has a similar option called \cc{-Wtautological-compare}.
%
We test these features by running latest versions of both compilers
against three simple error patterns extracted from the bugs discovered
by \sys.  The result as shown in \autoref{f:cmp-stat}.  GCC cannot
find any of them with \cc{-Wall}; it can find two with \cc{-Wextra}
or \cc{-Wtype-limits}, but these options are usually turned off by
developers due to high false error rate.  Clang can find one of them
without any special options.
%
%Neither of the compilers can detect the third error pattern, which
%is simply a variation of the second one.
%
We plan to push our work on integer error patterns into these C
compilers and improve their compile-time checking mechanism.

\begin{figure}
\centering
\input{data/cmp-stat}
\caption{Applying GCC and Clang to checking three simple integer
error patterns.  GCC can detect two, but only when \cc{-Wextra} is
given.  Clang can detect one without any special options.}
\label{f:cmp-stat}
\end{figure}

\subsection{Replacing Allocation Calls}

Integer errors that affect allocation size are particularly dangerous,
as discussed in \autoref{s:rank}.
We plan to develop a tool to prevent integer errors
in such cases at run time.
The idea is to extend the C compiler
to insert checks for integer operations that calculate allocation sizes.
If any of the checks fails at run time,
the inserted code forces the corresponding allocation call to return
\cc{NULL}, which we assume is handled by existing code
as out of memory.

\fi

\if 0
The grsecurity patch~\cite{grsecurity}
for the Linux kernel addresses the issue by replacing
\cc{kmalloc} with a macro of the same name.
%
\input{code/grsecurity-kmalloc}
%
Here \cc{intoverflow_t} is defined as the 128-bit unsigned integer
type.  The trick is that, assuming the developer often writes code
like \cc{kmalloc(count * size)}, with the macro of the same name
the C preprocessor will silently change the call to
\cc{kmalloc((intoverflow_t)count * size)}, where \cc{count} is first
promoted to 128 bits for the computation.  This should be large
enough to detect most integer errors.

However, the trick does not work if the call is written in forms
like \cc{kmalloc(header_size + count * size)}, or the allocation
size is already computed before being passed to \cc{kmalloc}, such
as in \autoref{f:bridge}.
\fi
