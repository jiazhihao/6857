\section{NaN Integer Semantics}
\label{s:miti}

\if 0
Writing integer error checks is tedious and error-prone.
Even for a simple multiplication \cc{n * size} that is often used
as the allocation size for an array, programmers would
have to write a non-trivial overflow check like \cc{(size \&\& n >
SIZE_MAX / size)}.  We contributed \cc{kmalloc_array(n, size)}
to help perform the check, which landed in the Linux kernel v3.4-rc1.
\fi

\autoref{s:eval} shows that a major source of integer errors is due
to unanticipated integer wraparound.  To mitigate the issue, we
propose a new integer family with NaN semantics: the value enters
and stays in an error state once an integer error occurs.
%
This section will illustrate how NaN integers help automate integer
error checking.

The basic usage is to add a type qualifier \cc{nan}
to an actual integer type, such as \cc{nan size_t}.
\begin{itemize}
\item
An integer of type $T$ will be automatically promoted to $\cc{nan}\ T$
when used with an integer of type $\cc{nan}\ T$.
\item
The result type of an arithmetic or comparison operation with
operands of type $\cc{nan}\ T$ is also $\cc{nan}\ T$.
\end{itemize}
We implement NaN integers by modifying the Clang compiler.
The compiler inserts error checks for every arithmetic or
comparison operation of type $\cc{nan}\ T$, and sets the result to
NaN if either any source operand is NaN or an integer error occurred
during the operation.
%
The compiler generates efficient overflow detection instructions
for these checks, depending on the target architecture.  For example,
the compiler inserts one \cc{jno} instruction after the multiplication,
which jumps if no overflow happened.

%\noindent
The NaN integer API consists of two functions:
\begin{itemize}
\item
$\cc{bool}\ \cc{isnan}(\cc{nan}\ T\; x)$ \hfill (NaN testing) \\
returns true if $x$ is NaN, or false otherwise.
\item
$T\ \cc{unnan}(\cc{nan}\ T\; x,\; T\; v)$ \hfill (integer casting) \\
returns $v$ if $x$ is NaN, or $(T)x$ otherwise.
\end{itemize}
With the API, we modify \cc{malloc} to take an \cc{nan size_t} as
the allocation size, as follows.
\input{code/malloc-nan}
The modified \cc{malloc} would change the allocation size to a large
value \cc{SIZE_MAX} if \cc{size} is NaN (i.e., the calculation
overflowed).  We assume that \cc{libc_malloc(SIZE_MAX)} returns
NULL due to a too large allocation size.

Below is an example use case.
\input{code/use-nan}
In this way, programmers do not have to write any overflow checks
when calculating the allocation size.

\begin{figure}
\centering
\input{data/nan-micro}
\caption{Performance overhead of \cc{n * size},
using manual overflow check \cc{x != 0 \&\& y > UINT_MAX / x} and
automated check via NaN integers, for both w/o and w/ \cc{malloc}
cases, measured in cycles.}
\label{f:data:nan-micro}
\end{figure}

Below is the code of function \cc{mq_attr_ok} in Linux kernel IPC, with 
slight modification to make it clear.
\input{code/mq}
The above checks intend to return 0 if the result of \cc{lhs} 
overflows in unsigned long case, i.e. the expected result of \cc{lhs} exceeds 
$\cc{ULONG_MAX}$, otherwise it will return 1.   

With NaN integers, one can wrap the original tricky checks with
$\cc{isnan}$.
\input{code/mq-nan}

We further show that using NaN integers incurs little runtime
overhead.  The baselines are a simple multiplication \cc{x * y} and
that followed by a \cc{malloc} call (referred as w/o and w/
\cc{malloc}, respectively).  We measure the overhead introduced by
the manual overflow check \cc{x != 0 \&\& y > UINT_MAX / x}, and
that by the NaN integer's automated check inserted by the compiler,
respectively,
%
Each test is repeated 1,000~times, and in a single test, we repeat
the operation $10^6$ times and log arithmetic mean as the result.

\autoref{f:data:nan-micro} shows the results.
%
With a simple multiplication, the slowdown using NaN integers is
$34.5\%$.  If an additional \cc{malloc} call is present, the slowdown
drops to $3.8\%$.
%
The corresponding slowdown numbers for manual checking
are $700\%$ and $31.6\%$, respectively.
%
We believe that it is practical to adopt NaN integers for
replacing manual overflow checking with a low overhead.

\if 0
Below is an example check in the infiniband driver.
\input{code/ib-check}
In the check, \cc{wqe_size}, \cc{wr_count}, and \cc{sqe_count} are
all directly from user space, and thus their values can be any
(32-bit) integers.  Carefully crafted values would overflow the
multiplications and addition at the right-hand side and bypass
check.  To avoid overflows, one would need to write additional
checks, such as:
\input{code/ib-more}
With NaN integers, one needs to change the type of
\cc{wqe_size}, \cc{wr_count}, and \cc{sqe_count} to NaN integers,
and wrap the original check with $\cc{nan}(\dots, \cc{true})$.
\input{code/ib-nan}
\fi

\if 0

\subsection{Compiler Checking}

It would be useful to have the compiler check and warn against
integer errors, so that developers can fix these bugs
at compile time.  Ideally, the check should not slow down
the compilation too much, and the false error rate should be kept low,
so that developers are willing to enable the check.
%
Due to the above two concerns, one cannot directly integrate
\sys's solver-based approach into a compiler.  A pragmatic workaround
could be to match and warn against the common error patterns
summarized in \autoref{s:common}, which can be done efficiently
with a low false error rate.

Decent C compilers have some support for detecting integer error
patterns.
%
GCC provides \cc{-Wtype-limits} to warn if a comparison if always
true or false due to type range limits.
%however this
%option is not turned on even with \cc{-Wall}, probably because of
%its high false rate.
%
Clang has a similar option called \cc{-Wtautological-compare}.
%
We test these features by running latest versions of both compilers
against three simple error patterns extracted from the bugs discovered
by \sys.  The result as shown in \autoref{f:cmp-stat}.  GCC cannot
find any of them with \cc{-Wall}; it can find two with \cc{-Wextra}
or \cc{-Wtype-limits}, but these options are usually turned off by
developers due to high false error rate.  Clang can find one of them
without any special options.
%
%Neither of the compilers can detect the third error pattern, which
%is simply a variation of the second one.
%
We plan to push our work on integer error patterns into these C
compilers and improve their compile-time checking mechanism.

\begin{figure}
\centering
\input{data/cmp-stat}
\caption{Applying GCC and Clang to checking three simple integer
error patterns.  GCC can detect two, but only when \cc{-Wextra} is
given.  Clang can detect one without any special options.}
\label{f:cmp-stat}
\end{figure}

\subsection{Replacing Allocation Calls}

Integer errors that affect allocation size are particularly dangerous,
as discussed in \autoref{s:rank}.
We plan to develop a tool to prevent integer errors
in such cases at run time.
The idea is to extend the C compiler
to insert checks for integer operations that calculate allocation sizes.
If any of the checks fails at run time,
the inserted code forces the corresponding allocation call to return
\cc{NULL}, which we assume is handled by existing code
as out of memory.

\fi

\if 0
The grsecurity patch~\cite{grsecurity}
for the Linux kernel addresses the issue by replacing
\cc{kmalloc} with a macro of the same name.
%
\input{code/grsecurity-kmalloc}
%
Here \cc{intoverflow_t} is defined as the 128-bit unsigned integer
type.  The trick is that, assuming the developer often writes code
like \cc{kmalloc(count * size)}, with the macro of the same name
the C preprocessor will silently change the call to
\cc{kmalloc((intoverflow_t)count * size)}, where \cc{count} is first
promoted to 128 bits for the computation.  This should be large
enough to detect most integer errors.

However, the trick does not work if the call is written in forms
like \cc{kmalloc(header_size + count * size)}, or the allocation
size is already computed before being passed to \cc{kmalloc}, such
as in \autoref{f:bridge}.
\fi
