\section{Mitigation Strategies}
\label{s:miti}

\fk{make clear that there are two new mitigation proposals.  i would lead with
  the type.  this section needs a careful writing pass.  happy to do so one it
  has been flushed out.}

Writing integer error checks is tedious and error-prone.
Even for a simple multiplication \cc{n * size} that is often used
as the allocation size for an array, programmers would
have to write a non-trivial overflow check like \cc{(size \&\& n >
SIZE_MAX / size)}.  We contributed \cc{kmalloc_array(n, size)}
to help perform the check, which landed in the Linux kernel v3.4-rc1.

\xw{to be revised.}
may forget to perform a check, or use wrong bounds that some inputs
can bypass. \xw{reference results from eval.}
When the expression gets more complex,
programmers would have to write checks for every arithmetic operation.

To automate integer error checking, we propose a new integer type that provides
not-a-number (NaN) semantics once it overflows, and remains NaN in future
computations.

The basic usage of NaN integers is to add a type qualifier \cc{nan}
to an actual integer type, such as \cc{nan size_t}.
\begin{itemize}
\item
An integer of type $T$ will be automatically promoted to $\cc{nan}\ T$
when used with an integer of type $\cc{nan}\ T$.
\item
The result type of an arithmetic or comparison operation with
operands of type $\cc{nan}\ T$ is also $\cc{nan}\ T$.
\end{itemize}
We implement NaN integers by modifying the Clang compiler.
The compiler inserts error checks for every arithmetic or
comparison operation of type $\cc{nan}\ T$, and sets the result to
NaN if either any source operand is NaN or an integer error occurred
during the operation.

The compiler generates efficient overflow detection instructions
for these checks, depending on the target architecture.  For example,
to detect a multiplication overflow on x86, the compiler may only
\fk{may? it inserts nor no inserts.}
need to insert one \cc{jno} instruction after the multiplication,
which jumps if no overflow happened.

\noindent
The NaN integer API consists of two functions:
\begin{itemize}
\item
$\cc{bool}\ \cc{isnan}(\cc{nan}\ T\; x)$ \hfill (NaN testing) \\
returns true if $x$ is NaN, or false otherwise.
\item
$T\ \cc{unnan}(\cc{nan}\ T\; x,\; T\; v)$ \hfill (integer casting) \\
returns $v$ if $x$ is NaN, or $(T)x$ otherwise.
\end{itemize}
With the API, we modify \cc{malloc} to take an \cc{nan size_t} as
the allocation size, as follows.
\input{code/malloc-nan}
The modified \cc{malloc} would change the allocation size to a large
value \cc{SIZE_MAX} if \cc{size} is NaN (i.e., the calculation
overflowed).  We assume that \cc{libc_malloc(SIZE_MAX)} returns
NULL due to a too large allocation size.

Below is an example use case.
\input{code/use-nan}
In this way, programmers do not have to write any overflow checks
when calculating the allocation size.

We modified the e1000 driver in the Linux kernel to use NaN integers
for all allocation sizes.
\xw{changed less than 20 lines of code. the slowdown is negligible.
still want to talk about infiniband?}

We use \cc{x * y} as a microbenchmark to measure the runtime
overhead introduced by the manual overflow check \cc{x != 0 \&\& y
> UINT_MAX / x}, and that by the NaN integer's automated check
inserted by the compiler, respectively.
%
The baselines are a simple multiplication and that followed by a
\cc{malloc} call, noted as w/o and w/ \cc{malloc}, respectively.

\autoref{f:data:nan-micro} shows the results. Each test is repeated 1000 times,
and in a single test, we repeat the operation $10^6$ times and log arithmetic mean
as the result.
%
In w/o \cc{malloc} cases, the manual check incurs $7\times$ slowdown, while
the slowdown using NaN integers is only $34.5\%$;
\fk{don't switch between $\times$ and \%}
%
In w/ \cc{malloc} cases, the slowdown numbers are $31.6\%$ and $3.8\%$,
respectively.
%
We can see that the NaN integer checks are more efficient than
manual checks.
\fk{Is the problem that programmers don't write checks because they are worried
  about the performance impact?}

\begin{figure}
\centering
\input{data/nan-micro}
\caption{Performance overhead of an multiplication \cc{n * size}, using
manual overflow check \cc{x != 0 \&\& y > UINT_MAX / x} and automated
check via NaN integers, measured in cycles.}
\label{f:data:nan-micro}
\end{figure}

\if 0
Below is an example check in the infiniband driver.
\input{code/ib-check}
In the check, \cc{wqe_size}, \cc{wr_count}, and \cc{sqe_count} are
all directly from user space, and thus their values can be any
(32-bit) integers.  Carefully crafted values would overflow the
multiplications and addition at the right-hand side and bypass
check.  To avoid overflows, one would need to write additional
checks, such as:
\input{code/ib-more}
With NaN integers, one needs to change the type of
\cc{wqe_size}, \cc{wr_count}, and \cc{sqe_count} to NaN integers,
and wrap the original check with $\cc{nan}(\dots, \cc{true})$.
\input{code/ib-nan}
\fi

\if 0

\subsection{Compiler Checking}

It would be useful to have the compiler check and warn against
integer errors, so that developers can fix these bugs
at compile time.  Ideally, the check should not slow down
the compilation too much, and the false error rate should be kept low,
so that developers are willing to enable the check.
%
Due to the above two concerns, one cannot directly integrate
\sys's solver-based approach into a compiler.  A pragmatic workaround
could be to match and warn against the common error patterns
summarized in \autoref{s:common}, which can be done efficiently
with a low false error rate.

Decent C compilers have some support for detecting integer error
patterns.
%
GCC provides \cc{-Wtype-limits} to warn if a comparison if always
true or false due to type range limits.
%however this
%option is not turned on even with \cc{-Wall}, probably because of
%its high false rate.
%
Clang has a similar option called \cc{-Wtautological-compare}.
%
We test these features by running latest versions of both compilers
against three simple error patterns extracted from the bugs discovered
by \sys.  The result as shown in \autoref{f:cmp-stat}.  GCC cannot
find any of them with \cc{-Wall}; it can find two with \cc{-Wextra}
or \cc{-Wtype-limits}, but these options are usually turned off by
developers due to high false error rate.  Clang can find one of them
without any special options.
%
%Neither of the compilers can detect the third error pattern, which
%is simply a variation of the second one.
%
We plan to push our work on integer error patterns into these C
compilers and improve their compile-time checking mechanism.

\begin{figure}
\centering
\input{data/cmp-stat}
\caption{Applying GCC and Clang to checking three simple integer
error patterns.  GCC can detect two, but only when \cc{-Wextra} is
given.  Clang can detect one without any special options.}
\label{f:cmp-stat}
\end{figure}

\subsection{Replacing Allocation Calls}

Integer errors that affect allocation size are particularly dangerous,
as discussed in \autoref{s:rank}.
We plan to develop a tool to prevent integer errors
in such cases at run time.
The idea is to extend the C compiler
to insert checks for integer operations that calculate allocation sizes.
If any of the checks fails at run time,
the inserted code forces the corresponding allocation call to return
\cc{NULL}, which we assume is handled by existing code
as out of memory.

\fi

\if 0
The grsecurity patch~\cite{grsecurity}
for the Linux kernel addresses the issue by replacing
\cc{kmalloc} with a macro of the same name.
%
\input{code/grsecurity-kmalloc}
%
Here \cc{intoverflow_t} is defined as the 128-bit unsigned integer
type.  The trick is that, assuming the developer often writes code
like \cc{kmalloc(count * size)}, with the macro of the same name
the C preprocessor will silently change the call to
\cc{kmalloc((intoverflow_t)count * size)}, where \cc{count} is first
promoted to 128 bits for the computation.  This should be large
enough to detect most integer errors.

However, the trick does not work if the call is written in forms
like \cc{kmalloc(header_size + count * size)}, or the allocation
size is already computed before being passed to \cc{kmalloc}, such
as in \autoref{f:bridge}.
\fi
