\section{Mitigation}
\label{s:miti}

\subsection{Compiler Integration}

compiler support: warn common error patterns.

\subsection{Runtime Check}

The grsecurity~\cite{grsecurity} patch, aiming to enhance the
security of the Linux kernel, addresses the integer error issue
in \cc{kmalloc} calls by defining a macro of the same name.
%
\input{code/grsecurity-kmalloc}
%
Here \cc{intoverflow_t} is defined as the 128-bit unsigned integer
type.  The trick is that, assuming the developer often writes code
like \cc{kmalloc(n * sizeof(...))}, with the macro of the same name
the C preprocessor will silently change the call to
\cc{kmalloc((intoverflow_t)n * sizeof(...))}, where \cc{n} is first
promoted to 128 bits for the computation.  This should be large
enough to detect most integer errors.  However, it does not work
if the allocation size is already computed before being passed to
\cc{kmalloc}, such as in \autoref{f:bridge}.

when writing your own allocator, don't repeat the mistake that
happened in glibc and Microsoft's libc~\cite{rus-cert:calloc}.

\subsection{Using an Integer Library}

One approach to secure the code is to enforce the use of an integer library
with overflow checks. [[[ examples: ms's libs ]]]
However, developers have to (re)write their
code using library functions like $\cc{addsl}(x, y)$ rather than
intuitive arithmetic operators like $x + y$ for addition of two signed
long integers.

Developers also have to make sure that the integer library itself
is implemented correctly.  Below is the implementation of \cc{addsl}
in CERT's IntegerLib.
%
\input{code/addsl}
%
We believe the code is broken in two ways. First, \cc{sizeof(int)}
should be \cc{sizeof(signed long)}, otherwise the code would
trigger false alarms on a 64-bit system.  Second, \cc{addsl}
(as well as other \cc{adds}* functions)
relies on undefined behavior, i.e., signed overflow of \cc{lhs+rhs},
to defend against overflow.  This would case [[[cite]]].  Also other
library bugs in Mozilla.

\subsection{Language Design}

type-safe languages: not so exploitable, DoS more likely

logic bugs are still there.

Removing unsigned types from the language does not help much.  For
example, Java only supports signed integers.  Embarrassingly, its
binary search implementation contained an integer overflow bug which
was not fixed until JDK~6~\cite{java-bsearch}.  When calculating
the midpoint with $(\cc{low} + \cc{high})/2$, which is the intuitive
way, the expression becomes negative for large $\cc{low}$ and
$\cc{high}$.  A correct version for signed integers is $\cc{low} +
(\cc{high}-\cc{low})/2$.  In the C language one may simply declare
$\cc{low}$ and $\cc{high}$ as unsigned integers to avoid the problem.


Some functional and scripting languages such as Haskell,
Python, and Ruby provide built-in bignum support. Though sacrificing
performance, using bignum is conceptually more immune to integer
vulnerabilities.
%
Interestingly, the underlying bignum implementation itself,
often written in C, may contain vulnerabilities.
CVE-2011-0188 is a recent example discovered in Ruby's bignum,
shown as below.
\input{code/ruby}
The truncation may cause \cc{xmalloc} to allocate a smaller buffer
than expected, leading to a buffer overflow.

\if 0
range annotations?  something like?
\begin{Verbatim}
#define RANGE(lo, hi) __attribute__((range(lo, hi)))
#define MAX_ELTS 1024

struct X {
	unsigned int nelts RANGE(1, MAX_ELTS);
	struct Y *elts;
};
\end{Verbatim}
Then you can do instrumentation on stores of nelts.
Better runtime checks \& good for static analysis.
\fi
