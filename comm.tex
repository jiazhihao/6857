\section{Common Pitfalls}
\label{s:common}

This section summarizes common integer error patterns and the way
to fix them.

A large portion of integer errors found in the Linux kernel are
due to missing or incorrect bound checks for data from untrusted
sources.  The fix is simply to add or correct the sanity check,
and return \cc{-EINVAL} or silently limit the value to the bounds.

Multiplication in for calculating allocation size seems particularly
prone to integer errors.  The Linux kernel provides the function
\cc{kcalloc(count, size)} that checks for multiplication overflow
of \cc{count} and \cc{size} and additionally zeroes the allocated
memory.  In fact, almost every call to \cc{kzalloc(count * size)},
which also zeros the memory, may be substituted with \cc{kcalloc}
for better reliability.  In less performance-critical code,
\cc{kmalloc} may be substituted with \cc{kcalloc}, too.  In user
space, \cc{calloc} may be used in favor of \cc{malloc} similarly.

The obviously wrong check $(\cc{uint} < 0)$, often used for return
values, yet has appeared in several drivers and even the core kernel.
A trickier form is $(\cc{uchar} < 0)$, where the left-hand side is
zero-extended so that it can never be negative.  In most cases the
fix is to simply use the signed type instead.

char$\to$int: 
CA-1996-22,
Apache,
lighttpd new bug

%oversized shift (Google's Native Client sandboxing),
%ABI on 64-bit S/390, PowerPC, SPARC, and MIPS
%and 32-bit system call parameters~\cite[CVE-2009-0029]{cve}

index checks:
miss (i < 0) or should declare i as unsigned


%interface change (e.g., CVE-2009-2909)
%sometimes infeasible if the interface is exposed to userspace.

when writing your own allocator, don't repeat the mistake that
happened in glibc and Microsoft's libc~\cite{rus-cert:calloc}.
