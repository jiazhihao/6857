\section{Overview}
\label{s:oview}

This section gives an overview of \sys's goals and challenges.

\subsection{Integer Security}

\sys adopts the CERT C secure coding standard for integer
operations~\cite[Ch.~5]{seacord:secure-c} as a basis and considers
operations that violate the coding standard as integer errors.  We
will summarize them below (see \autoref{s:sema} for a formal
definition).

\sys assumes two's complement~\cite[Ch.~4.2.1]{intel:vol1}, a de
facto standard integer representation on modern architectures.  An
$n$-bit unsigned integer is in the range $0$ to $2^n-1$, while an
$n$-bit signed integer is in the range $-2^{n-1}$ to $2^{n-1}-1$,
with the most significant bit indicating the sign.  If not particularly
indicated, $x$ and $y$ below are $n$-bit integers.

\noindent
{\it Addition \& subtraction \& multiplication}.
$x\ \textrm{op}\ y$ is considered insecure if the result of the
corresponding arbitrary-precision mathematical operation may fall
out of the predefined range.  For example, $\cc{maxnum}\times
16$ in \autoref{f:bridge} is insecure because mathematically
$\cc{0xf0000000} \times 16 = 2^{32}\times 3\times 5$, which is out
of the predefined range of $32$-bit unsigned integers ($0$ to $2^{32}
- 1$).

\noindent
{\it Division}.
A division operation is insecure if the divisor is 0.  Additionally,
signed division $x\ /_s\ y$ is insecure if $x = -2^{n-1}$ and $y =
-1$, because the mathematical result $2^{n-1}$ is not in the range
of $n$-bit signed integers ($-2^{n-1}$ to $2^{n-1}-1$).

\noindent
{\it Shift}. $x \shl y$ and $x \shr y$ are insecure if $y \geq_u
n$, aka oversized shifts, which are undefined according to the C
standard.  For example, $(1 \shl 32)$ may yield 0 (e.g., x86) or 1
(e.g., ppc) for 32-bit integers, depending on the underlying
architecture.

\noindent
{\it Conversion}.
If $x$ is converted from integer type $s$ to $t$, the conversion
is insecure if the value of $x$ does not fall into the range of
$t$.  For example, $x \geq_s 0$ should hold if a signed integer $x$
is converted to unsigned, otherwise the conversion is considered
insecure.

\subsection{A Strawman Approach}

We outline a naive implementation of \sys and see how it works
for the example shown in \autoref{f:bridge}.

\sys performs symbolic analysis to compute the error condition and
the corresponding path condition for each integer operation.  As
for $\cc{maxnum} \times_u 16$, based on \autoref{s:sema}
we can compute its error condition is:
\begin{equation}\label{eq:bridge-ec}
\cc{maxnum} >_u (2^{32} - 1) / 16.
\end{equation}
Since the multiplication is always reachable, the corresponding
path condition is simply true.

\sys then feeds the logical AND of the two conditions into a
constraint solver~\cite{boolector}.  The solver computes a possible
error input.
\begin{equation*}
...
\end{equation*}

Now consider the patched code that correctly limits \cc{maxnum} to 256,
shown as follows.
\input{code/bridge-p}
The error condition is unchanged, the same as~\eqref{eq:bridge-ec}.

\subsection{Challenges}

NB: equivalence.
$x \times 16$ is not the same as $x \shl 4$.

type conversion: ppl mix signed/unsigned integers.

pointer arithmetic.

overflow checking idioms.

loops.

solver performance.
