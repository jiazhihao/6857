\section{Overview}
\label{s:oview}

\subsection{Integer Semantics}

\newcommand{\smin}{\mathrm{smin}}
\newcommand{\smax}{\mathrm{smax}}
\newcommand{\umax}{\mathrm{umax}}

\newcommand{\sadde}{\mathtt{sadd}_e}
\newcommand{\uadde}{\mathtt{uadd}_e}
\newcommand{\ssube}{\mathtt{ssub}_e}
\newcommand{\usube}{\mathtt{usub}_e}
\newcommand{\smule}{\mathtt{smul}_e}
\newcommand{\umule}{\mathtt{umul}_e}
\newcommand{\sdive}{\mathtt{sdiv}_e}
\newcommand{\udive}{\mathtt{udiv}_e}
\newcommand{\shle}{\mathtt{shl}_e}
\newcommand{\shre}{\mathtt{shr}_e}
\newcommand{\conve}{\mathtt{conv}_e}


what are considered to be correct/wrong?

This paper assumes two's complement~\cite{intel:int}, a de facto
standard way to represent either unsigned integers in the range $0$
to $2^n-1$, or signed integers in the range $-2^{n-1}$ to $2^{n-1}-1$,
with the most significant bit indicating the sign.

\begin{figure}
\begin{align}
\sadde(x, y)&: \\
\uadde(x, y)&: \\
\ssube(x, y)&: \\
\usube(x, y)&: \\
\smule(x, y)&: \\
\umule(x, y)&: x \neq 0 \land y >_u \umax / x \\
\sdive(x, y^n)&: y = 0 \lor (x = \smin \land y = -1) \\
\udive(x, y)&: y = 0 \\
\shle(x, y)&: y \geq_u n \\
\shre(x, y)&: y \geq_u n
\end{align}
\caption{Integer error conditions for integral operations.}
\end{figure}

\subsubsection*{Arithmetic}
\subsubsection*{Bitwise Shift}
\subsubsection*{Type Conversion}

\subsection{A Strawman Approach}

describe a strawman solution:
generate path conditions and integer constraints,
and feed into a solver.

\autoref{f:vmwgfx}.
multiplication overflow conditions.
\begin{align*}
\umule(\text{\lstinline!arg->num_outputs!}, 16)
\end{align*}
path guards.
\begin{align*}
\text{\lstinline!arg->num_outputs!} \neq 0
\end{align*}

consider two patches.

a bad one.
$x * y < x$.

and a correct one.

\subsection{Challenges}

type conversion: too many FPs;

pointer arithmetic.

overflow checking idioms.

loops.

solver performance.
