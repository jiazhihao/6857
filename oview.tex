\section{Overview}
\label{s:oview}

This section gives an overview of \sys's goals and challenges.

\subsection{Integer Security}
\label{s:goal}

\sys adopts the CERT C secure coding standard for integer
operations~\cite[\chapterautorefname~5]{seacord:secure-c} as a basis
and considers operations that violate the coding standard as integer
errors.  They cover a set of integer-based vulnerabilities, sometimes
referred as arithmetic overflow (underflow, wraparound), division-by-zero,
oversized shift, and signedness bugs in the literature.  We will
summarize them below.

\sys assumes two's complement~\cite[\chapterautorefname~4.2.1]{intel:vol1},
a de facto standard integer representation on modern architectures.
An $n$-bit unsigned integer is in the range $0$ to $2^n-1$, while
an $n$-bit signed integer is in the range $-2^{n-1}$ to $2^{n-1}-1$,
with the most significant bit indicating the sign.  If not particularly
indicated, $x$ and $y$ below are $n$-bit integers.  A subscript $s$
or $u$ may be pinned to an operation to specify it operates on
signed or unsigned integers.

\paragraph{Addition \& subtraction \& multiplication.}
Such an operation may lead to an integer error if the result of the
corresponding arbitrary-precision mathematical operation falls out
of the predefined range.  For example, $\cc{maxnum}\times_u 16$
causes an integer error if $\cc{maxnum} = \cc{0xf0000000}$, because
the mathematical product $\cc{0xf0000000} \times 16 = 2^{32}\times
3\times 5$ is out of the range of $32$-bit unsigned integers ($0$
to $2^{32} - 1$).

\paragraph{Division.}
A division operation causes an integer error if the divisor is 0.
Additionally, signed division $x\ /_s\ y$ may lead to an integer
error if $x = -2^{n-1}$ and $y = -1$, because the mathematical
result $2^{n-1}$ is not in the range of $n$-bit signed integers
($-2^{n-1}$ to $2^{n-1}-1$).

\paragraph{Shift.}
The bitwise shifts $x \shl y$ and $x \shr y$ are considered as
integer errors if $y \geq_u n$, which is undefined according to the
C standard.  For example, $(1 \shl 32)$ may yield 0 (e.g., x86) or
1 (e.g., PowerPC) for 32-bit integers, depending on the underlying
architecture.

\paragraph{Conversion.}
If $x$ is converted from integer type $s$ to $t$, the conversion
may lead to an integer error if the value of $x$ does not fall into
the range of $t$.

\paragraph{}
It is worth noting that with the secure integer standard two
functionally equivalent operations may have different error conditions.
It is assumed that developers have chosen the appropriate operations
to match their intention.  For example, $\cc{maxnum}\times_u 16$
may be erroneous if \cc{maxnum} is large, while $\cc{maxnum} \shl
4$ is considered always secure.  Any compiler optimization that
performs such code transformations would destroy the semantics.
Besides, decent C compilers may completely optimize away invalid
integer error checks like $(x + 1) < x$ for signed integer
$x$~\cite{gcc:signed-overflow,us-cert:gcc}, unless a special compile
option \cc{-fwrapv} or \cc{-fno-strict-overflow} is given.  Therefore,
\sys should work on pre-optimized code.

\subsection{A Strawman Approach}

We outline a naive implementation of \sys and see how it works
for the example shown in \autoref{f:bridge}.

\sys performs symbolic analysis to compute the error condition and
the corresponding path condition for each integer operation.  As
for $\cc{maxnum} \times_u 16$, \sys computes its error condition
as:
\begin{equation*}
\cc{maxnum} >_u (2^{32} - 1) / 16.
\end{equation*}
Since the multiplication is always reachable, the corresponding
path condition is simply true.

\sys then feeds the logical AND of the two conditions into a
constraint solver~\cite{boolector}.  The solver computes a possible
input, e.g., \cc{0xf0000000}, for \cc{maxnum}.

Now let's consider the patched code that correctly limits \cc{maxnum}
to 256, shown as follows (\cc{maxnum} is
numbered~\cite[\chapterautorefname~8.11]{whale} for clarification
purpose).
\input{code/bridge-p}
This time the error condition remains unchanged.
\begin{equation*}
\cc{maxnum}_1 >_u (2^{32} - 1) / 16.
\end{equation*}
The corresponding path condition is that \cc{maxnum} is reset to 256
if it is larger than 256, or remains the old value otherwise.
\begin{align*}
& ((\cc{maxnum}_0 >_u 256) \land (\cc{maxnum}_1 = 256)) \\
\lor
& (\neg (\cc{maxnum}_0 >_u 256) \land (\cc{maxnum}_1 = \cc{maxnum}_0)).
\end{align*}
Again \sys takes the logical AND of the two conditions to the
constraint solver, which will conclude that these conditions can
never be satisfied.  This means that the integer error has been
fixed.

\subsection{Challenges}
\label{s:chal}

There are several challenges that face \sys when applying the
secure integer standard described in \autoref{s:goal} to real-world
systems code.

\subsubsection{Benign Integer Errors}

While violating the secure integer standard, some commonly-used C
idioms will not cause any defects.  We recognize them as follows.

\paragraph{Partial violation.}
Consider $(x +_u 1) -_u 2$ with $x \geq_u 1$.  The expression would
be considered as an integer error since the first part $(x +_u 1)$
may be insecure, though the whole expression is equivalent to $x
-_u 1$ and will not cause any integer error.  Another example is
that signed and unsigned integers are often used interchangeably in
C code.  In a conversion like \cc{(int)((unsigned)x)} for a signed
$x <_s 0$, the part \cc{(unsigned)x} may violate the secure integer
standard while the whole expression does not.  \sys should avoid
to warn such ``partial'' violations.

\paragraph{Error-before-use.}
Sometimes an integer error check comes after the overflowed
computation, but before any use of the overflowed result.  Below
is such an example.
\input{code/error-before-use}
\sys should avoid to warn $x \times_u y$ since the product is not
used before the check.

\paragraph{Overflowed checking idiom.}
It is commonly seen in practice to use an overflowed result to do
the integer error check for $x +_u y$:
\begin{align}
x +_u y <_u x.
\end{align}
This is equivalent to a ``sane'' check
$\cc{UINT_MAX} - x >_u y$.
\sys should avoid warn such integer error checking idioms.

Note that using overflowed result to check multiplication is trickier.
In general $x \times_u y <_u x$ is not a valid integer error check
but a bug.  A correct way would be $(x \times_u y) /_u y \neq x$
or a sane check, $\cc{UINT_MAX} /_u x > y$.

\subsubsection{Complex Program Constructs}

Loops.

Pointer arithmetic.

\subsubsection{Constraint Solving Performance}

Although the constraint solver that \sys uses is highly optimized,
constraints generated unwisely would still hurt its performance.

First, the size of the constraints should be bounded.  It is not a
good idea, for example, to naively analyze and generate constraints
across the whole Linux kernel.  To achieve scalability, \sys
should choose an appropriate program granularity.

Besides, we notice that some operations like division significantly slow down
the constraint solver, most of which are used in integer error checks
like $\cc{UINT_MAX} /_u x > y$.  \sys should recognize these
idioms and generate constraints that are easier to solve.
