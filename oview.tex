\section{Overview}
\label{s:oview}

This section gives an overview of \sys's goals and challenges.

\subsection{Integer Security}
\label{s:goal}

\sys adopts the CERT C secure coding standard for integer
operations~\cite[\chapterautorefname~5]{seacord:secure-c} as a basis
and considers operations that violate the coding standard as integer
errors.  We will summarize them below (see \autoref{s:sema} for a
formal definition).

\sys assumes two's complement~\cite[\chapterautorefname~4.2.1]{intel:vol1},
a de facto standard integer representation on modern architectures.
An $n$-bit unsigned integer is in the range $0$ to $2^n-1$, while
an $n$-bit signed integer is in the range $-2^{n-1}$ to $2^{n-1}-1$,
with the most significant bit indicating the sign.  If not particularly
indicated, $x$ and $y$ below are $n$-bit integers.  A subscript $s$
or $u$ may be pinned to an operation to specify it operates on
signed or unsigned integers.

\noindent
{\it Addition \& subtraction \& multiplication}.
$x\ \textrm{op}\ y$ is considered insecure if the result of the
corresponding arbitrary-precision mathematical operation may fall
out of the predefined range.  For example, $\cc{maxnum}\times_u
16$ in \autoref{f:bridge} is insecure because mathematically
$\cc{0xf0000000} \times 16 = 2^{32}\times 3\times 5$, which is out
of the predefined range of $32$-bit unsigned integers ($0$ to $2^{32}
- 1$).

\noindent
{\it Division}.
A division operation is insecure if the divisor is 0.  Additionally,
signed division $x\ /_s\ y$ is insecure if $x = -2^{n-1}$ and $y =
-1$, because the mathematical result $2^{n-1}$ is not in the range
of $n$-bit signed integers ($-2^{n-1}$ to $2^{n-1}-1$).

\noindent
{\it Shift}. $x \shl y$ and $x \shr y$ are insecure if $y \geq_u
n$, aka oversized shifts, which are undefined according to the C
standard.  For example, $(1 \shl 32)$ may yield 0 (e.g., x86) or 1
(e.g., ppc) for 32-bit integers, depending on the underlying
architecture.

\noindent
{\it Conversion}.
If $x$ is converted from integer type $s$ to $t$, the conversion
is insecure if the value of $x$ does not fall into the range of
$t$.  For example, $x \geq_s 0$ should hold if a signed integer $x$
is converted to unsigned, otherwise the conversion is considered
insecure.

It is worth noting that using the security semantics two functionally
equivalent operations may have different error conditions.  It is
assumed that developers have chosen the appropriate operations to
match their intention.  For example, $\cc{maxnum}\times_u 16$ may
be insecure if \cc{maxnum} is large, while $\cc{maxnum} \shl 4$ is
considered always secure.  Any compiler optimization that performs
such code transformations would destroy the security semantics.
Therefore, it implies that \sys must work on pre-optimized code.

\subsection{A Strawman Approach}

We outline a naive implementation of \sys and see how it works
for the example shown in \autoref{f:bridge}.

\sys performs symbolic analysis to compute the error condition and
the corresponding path condition for each integer operation.  As
for $\cc{maxnum} \times_u 16$, based on \autoref{s:sema}
\sys computes its error condition as:
\begin{equation*}
\cc{maxnum} >_u (2^{32} - 1) / 16.
\end{equation*}
Since the multiplication is always reachable, the corresponding
path condition is simply true.

\sys then feeds the logical AND of the two conditions into a
constraint solver~\cite{boolector}.  The solver computes a possible
input, e.g., \cc{0xf0000000}, for \cc{maxnum}.

Now let's consider the patched code that correctly limits \cc{maxnum}
to 256, shown as follows (\cc{maxnum} is
numbered~\cite[\chapterautorefname~8.11]{whale} for clarification
purpose).
\input{code/bridge-p}
This time the error condition remains unchanged.
\begin{equation*}
\cc{maxnum}_1 >_u (2^{32} - 1) / 16.
\end{equation*}
The corresponding path condition is that \cc{maxnum} is reset to 256
if it is larger than 256, or remains the old value otherwise.
\begin{align*}
& ((\cc{maxnum}_0 >_u 256) \land (\cc{maxnum}_1 = 256)) \\
\lor
& (\neg (\cc{maxnum}_0 >_u 256) \land (\cc{maxnum}_1 = \cc{maxnum}_0)).
\end{align*}
Again \sys takes the logical AND of the two conditions to the
constraint solver, which will conclude that these conditions can
never be satisfied.  This means that the integer error has been
fixed.

\subsection{Challenges}
\label{s:chal}

There are several challenges that face \sys when applying the
security semantics described in \autoref{s:goal} to real-world
systems code.

\subsubsection*{Benign Integer Errors}

type conversion: ppl mix signed/unsigned integers.

overflow checking idioms.

\subsubsection*{Complex Program Constructs}

loops.

pointer arithmetic.

\subsubsection*{Constraint Solving Performance}

generate constraints wisely?

intra-procedurally?

