\section{Overview}
\label{s:oview}

This section gives an overview of \sys's goals and challenges.

\subsection{Integer Security}

\sys adopts the CERT C secure coding
standard~\cite[Ch.~5]{seacord:secure-c} as a basis for detecting
insecure integer operations, summaried as follows (see \autoref{s:sema}
for a formal definition).

\sys assumes two's complement~\cite[Ch.~4.2.1]{intel:vol1}, a de
facto standard integer representation on most modern architectures.
$n$ bits are used to represent either unsigned integers in the range
$0$ to $2^n-1$, or signed integers in the range $-2^{n-1}$ to
$2^{n-1}-1$, with the most significant bit indicating the sign.  If
not particularly indicated, $x$ and $y$ are $n$-bit integers in
this subsection.

\noindent
{\it Addition \& subtraction}.
Extend $x$ and $y$ to $n+1$ bits and perform the addition / subtraction.
The operation is insecure if the result does not fall into the range of
$n$-bit integers.  For example, ...

\noindent
{\it Multiplication}.
Extend $x$ and $y$ to $2n$ bits and perform the multiplication.
The operation is insecure if the result does not fall
into the range of $n$-bit integers.

\noindent
{\it Division}.
The operation is insecure if the divisor is 0, Additionally, signed
division $x\ /_s\ y$ is insecure if $x = -2^{n-1}$ and $y = -1$,
because the result $2^{n-1}$ cannot be represented by an $n$-bit
signed integer.

\noindent
{\it Shift}. $x \shl y$ and $x \shr y$ are insecure if $y \geq n$,
because oversized shifts are undefined in C.  For example, $(1 \shl
32)$ may yield 0 or 1 for 32-bit integers, depending on the underlying
architecture.

\noindent
{\it Conversion}.
If $x$ is converted from type $s$ to $t$, the conversion is insecure
if the value of $x$ does not fall into the range of $t$.  For example,
...

We use $(x\ \mathrm{op}\ y)_e$ to denote the predicate under which
the operation $x\ \mathrm{op}\ y$ is insecure.
For example, 
\begin{align*}
\umule{\cc{arg->num_outputs}}{16}
\end{align*}
gives the predicate
\begin{align*}
\cc{arg->num_outputs} >_u (2^{32} - 1) / 16,
\end{align*}
since the product will overflow if the predicate is true.

\subsection{A Strawman Approach}

describe a strawman solution:
generate path conditions and integer constraints,
and feed into a solver.

\autoref{f:vmwgfx}.
multiplication overflow conditions.
\begin{align*}
e = \umule{\cc{arg->num_outputs}}{16}
\end{align*}
path conditions.
\begin{align*}
g = \cc{arg->num_outputs} \neq 0
\end{align*}

The predicate for the solver is $e \land g$.

consider two patches.

a bad one.
$x * y < x$.

and a correct one.

\subsection{Challenges}

NB: equivalence.
$x \times 16$ is not the same as $x \shl 4$.

type conversion: ppl mix signed/unsigned integers.

pointer arithmetic.

overflow checking idioms.

loops.

solver performance.
