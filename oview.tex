\section{Overview}
\label{s:oview}

This section gives an overview of \sys's goals and challanges.

\subsection{Integer Semantics}

\newcommand{\smin}{\mathrm{smin}}
\newcommand{\smax}{\mathrm{smax}}
\newcommand{\umax}{\mathrm{umax}}

\newcommand{\sadde}{\mathtt{sadd}_e}
\newcommand{\uadde}{\mathtt{uadd}_e}
\newcommand{\ssube}{\mathtt{ssub}_e}
\newcommand{\usube}{\mathtt{usub}_e}
\newcommand{\smule}{\mathtt{smul}_e}
\newcommand{\umule}{\mathtt{umul}_e}
\newcommand{\sdive}{\mathtt{sdiv}_e}
\newcommand{\udive}{\mathtt{udiv}_e}
\newcommand{\shle}{\mathtt{shl}_e}
\newcommand{\shre}{\mathtt{shr}_e}
\newcommand{\conve}{\mathtt{conv}_e}

RICH~\cite{brumley:rich}

what are considered to be correct/wrong?

\sys assumes two's complement~\cite{intel:int}, a de facto
standard way to represent either unsigned integers in the range $0$
to $2^n-1$, or signed integers in the range $-2^{n-1}$ to $2^{n-1}-1$,
with the most significant bit indicating the sign.

\subsubsection*{Arithmetic}

unsigned multiplication.
\begin{align}
\umule(x, y)&: x \neq 0 \land y >_u \umax / x
\end{align}


%\sdive(x, y^n)&: y = 0 \lor (x = \smin \land y = -1) \\
%\udive(x, y)&: y = 0 \\

\subsubsection*{Bitwise Shift}

\begin{align}
\shle(x, y)&: y \geq_u n \\
\shre(x, y)&: y \geq_u n
\end{align}

\subsubsection*{Type Conversion}


\subsection{A Strawman Approach}

describe a strawman solution:
generate path conditions and integer constraints,
and feed into a solver.

\autoref{f:vmwgfx}.
multiplication overflow conditions.
\begin{align*}
e = \umule(\cc{arg->num_outputs!}, 16)
\end{align*}
path conditions.
\begin{align*}
g = \cc{arg->num_outputs!} \neq 0
\end{align*}

The predicate for the solver is $e \land g$.

consider two patches.

a bad one.
$x * y < x$.

and a correct one.

\subsection{Challenges}

how to generate constraints?

type conversion: ppl mix signed/unsigned integers.

pointer arithmetic.

overflow checking idioms.

loops.

solver performance.
